import Foundation

public class DBSoupSVGGenerator {
    private let document: DBSoupDocument
    private let backgroundColor: String?
    private let rawContent: String?
    
    public init(document: DBSoupDocument, backgroundColor: String? = "#ecf0f1", rawContent: String? = nil) {
        self.document = document
        self.backgroundColor = backgroundColor
        self.rawContent = rawContent
    }
    
    // MARK: - Background Color Presets
    
    /// Recommended background colors for professional appearance
    public static let backgroundColors = BackgroundColors()
    
    public struct BackgroundColors {
        public let transparent: String? = nil
        public let lightGrey = "#f5f5f5"
        public let mediumGrey = "#e8e8e8"
        public let blueGrey = "#ecf0f1"      // Default background color
        public let warmGrey = "#f8f9fa"
        public let documentWhite = "#ffffff"
    }
    
    // MARK: - Attribution Constants
    
    /// Attribution text displayed in the generated SVG
    private static let attributionTitle = "Generated by DBSoup"
    private static let attributionSubtitle = "Database Schema Visualization"
    
    // MARK: - Version Display Constants
    
    /// Schema version label displayed in the generated SVG
    public static var schemaVersionLabel = "Db Schema v"
    
    // MARK: - Convenience Initializers
    
    /// Creates SVG generator with transparent background (no background color)
    public static func withTransparentBackground(document: DBSoupDocument) -> DBSoupSVGGenerator {
        return DBSoupSVGGenerator(document: document, backgroundColor: backgroundColors.transparent)
    }
    
    /// Creates SVG generator with light grey background (recommended for maximum contrast)
    public static func withLightGreyBackground(document: DBSoupDocument) -> DBSoupSVGGenerator {
        return DBSoupSVGGenerator(document: document, backgroundColor: backgroundColors.lightGrey)
    }
    
    /// Creates SVG generator with blue-grey background (default, professional look)
    public static func withBlueGreyBackground(document: DBSoupDocument) -> DBSoupSVGGenerator {
        return DBSoupSVGGenerator(document: document, backgroundColor: backgroundColors.blueGrey)
    }
    
    /// Creates SVG generator with warm grey background (recommended for documentation)
    public static func withWarmGreyBackground(document: DBSoupDocument) -> DBSoupSVGGenerator {
        return DBSoupSVGGenerator(document: document, backgroundColor: backgroundColors.warmGrey)
    }
    
    public func generateSVG() -> String {
        let _ = getAllEntities() // Keep for backward compatibility
        let entitiesByModule = getEntitiesByModule()
        let allRelationships = getAllRelationships()
        let architecturalOverview = extractArchitecturalOverview()
        
        // Calculate layout with dynamic sizing, legend space, and architectural overview
        let layout = calculateModularLayout(entitiesByModule: entitiesByModule, relationships: allRelationships, architecturalOverview: architecturalOverview)
        
        var svg = """
        <svg xmlns="http://www.w3.org/2000/svg" 
             viewBox="0 0 \(layout.totalWidth) \(layout.totalHeight)"
             preserveAspectRatio="xMidYMid meet">
        <defs>
            <linearGradient id="headerGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#4a90e2;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#357abd;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="entityGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#1a1a1a;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#2d2d2d;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="embeddedHeaderGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#ffeb3b;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#f1c40f;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="embeddedEntityGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#2d2410;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#3d3015;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="legendGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#2c3e50;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#34495e;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="legendHeaderGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#1abc9c;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#16a085;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="overviewGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#f8f9fa;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#e9ecef;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="moduleHeaderGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#3498db;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#2980b9;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="attributionGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.8" />
                <stop offset="100%" style="stop-color:#f8f9fa;stop-opacity:0.8" />
            </linearGradient>
            <linearGradient id="attributionBorderGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#667eea;stop-opacity:0.9" />
                <stop offset="25%" style="stop-color:#764ba2;stop-opacity:0.9" />
                <stop offset="50%" style="stop-color:#ff6b6b;stop-opacity:0.9" />
                <stop offset="75%" style="stop-color:#4ecdc4;stop-opacity:0.9" />
                <stop offset="100%" style="stop-color:#45b7d1;stop-opacity:0.9" />
            </linearGradient>
            <filter id="attributionShadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="2" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.15"/>
            </filter>
        </defs>
        <style>
        svg { width: 100%; height: auto; max-width: 100%; display: block; }
        .entity-box { fill: url(#entityGradient); stroke: #444444; stroke-width: 2; }
        .entity-header { fill: url(#headerGradient); stroke: #444444; stroke-width: 2; }
        .entity-title { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; fill: white; }
        .embedded-entity-box { fill: url(#embeddedEntityGradient); stroke: #f1c40f; stroke-width: 2; stroke-dasharray: 8,4; }
        .embedded-entity-header { fill: url(#embeddedHeaderGradient); stroke: #f1c40f; stroke-width: 2; stroke-dasharray: 8,4; }
        .embedded-entity-title { font-family: Arial, sans-serif; font-size: 15px; font-weight: bold; fill: #2c3e50; font-style: italic; }
        .field-text { font-family: 'SF Mono', 'Monaco', 'Consolas', monospace; font-size: 12px; font-weight: bold; }
        .embedded-field-text { font-family: 'SF Mono', 'Monaco', 'Consolas', monospace; font-size: 12px; font-weight: bold; }
        .entity-comment { fill: white; font-style: italic; font-size: 11px; font-weight: normal; }
        .embedded-entity-comment { fill: #2c3e50; font-style: italic; font-size: 11px; font-weight: normal; }
        .required { fill: #ffa502; }
        .optional { fill: #c7c7c7; }
        .indexed { fill: #5352ed; }
        .sensitive { fill: #ff4757; }
        .foreign-key { fill: #e056fd; cursor: pointer; }
        .embedded-entity-field { fill: #ffeb3b; cursor: pointer; }
        .embedded-required { fill: #ffa502; }
        .embedded-optional { fill: #c7c7c7; }
        .embedded-indexed { fill: #5352ed; }
        .embedded-sensitive { fill: #ff4757; }
        .embedded-foreign-key { fill: #e056fd; cursor: pointer; }
        .embedded-embedded-entity-field { fill: #ffeb3b; cursor: pointer; }
        
        /* Smooth transitions for interactive fields */
        .foreign-key, .embedded-foreign-key, .embedded-entity-field, .embedded-embedded-entity-field {
            transition: fill 0.2s ease-in-out, filter 0.2s ease-in-out;
        }
        
        /* Immediate hover feedback for interactive fields */
        .foreign-key:hover { 
            fill: #ff69b4; 
            filter: drop-shadow(0 0 6px rgba(224, 86, 253, 0.8)) brightness(1.2);
        }
        .embedded-foreign-key:hover { 
            fill: #ff69b4; 
            filter: drop-shadow(0 0 6px rgba(224, 86, 253, 0.8)) brightness(1.2);
        }
        .embedded-entity-field:hover { 
            fill: #ffff00; 
            filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.8)) brightness(1.2);
        }
        .embedded-embedded-entity-field:hover { 
            fill: #ffff00; 
            filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.8)) brightness(1.2);
        }
        
        /* Enhanced anchor styling for better UX */
        a {
            cursor: pointer !important;
            position: relative;
        }
        
        /* Instant custom tooltips for SVG */
        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
            font-weight: 500;
            fill: white;
            pointer-events: none;
            transition: opacity 0.1s ease-in;
        }
        
        .tooltip-bg {
            visibility: hidden;
            opacity: 0;
            fill: rgba(44, 62, 80, 0.95);
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 1;
            rx: 6;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.4));
            pointer-events: none;
            transition: opacity 0.1s ease-in;
        }
        
        .tooltip-group:hover .tooltip-bg,
        .tooltip-group:hover .tooltip-text,
        a:hover + .tooltip-group .tooltip-bg,
        a:hover + .tooltip-group .tooltip-text,
        .interactive-field:hover + .tooltip-group .tooltip-bg,
        .interactive-field:hover + .tooltip-group .tooltip-text,
        .interactive-field:hover ~ .tooltip-group .tooltip-bg,
        .interactive-field:hover ~ .tooltip-group .tooltip-text,
        .field-with-tooltip:hover .tooltip-bg,
        .field-with-tooltip:hover .tooltip-text,
        .constraint-tag-with-tooltip:hover .tooltip-bg,
        .constraint-tag-with-tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .legend-box { fill: url(#legendGradient); stroke: #34495e; stroke-width: 1; opacity: 1; }
        .legend-header { fill: url(#legendHeaderGradient); stroke: #16a085; stroke-width: 0; border-bottom: 1px solid #34495e; }
        .legend-title { font-family: Arial, sans-serif; font-size: 19px; font-weight: 900; fill: white; letter-spacing: 1.2px; }
        .legend-text { font-family: 'SF Mono', 'Monaco', 'Consolas', monospace; font-size: 11px; font-weight: bold; fill: #ecf0f1; text-shadow: 1px 1px 3px rgba(0,0,0,0.9); }
                        .legend-header-text { font-family: 'SF Mono', 'Monaco', 'Consolas', monospace; font-size: 11px; font-weight: 900; fill: #666666; }
        .legend-row-bg { fill: rgba(255,255,255,0.03); opacity: 1; }
        .legend-row { fill: none; stroke: #455a64; stroke-width: 1; opacity: 0.8; stroke-dasharray: 2,2; }
        .header-separator { stroke: #34495e; stroke-width: 1; opacity: 0.8; }
        .relationship-separator { fill: none; stroke: #7f8c8d; stroke-width: 1; opacity: 1.0; stroke-dasharray: 4,3; }
        .overview-title { font-family: Arial, sans-serif; font-size: 18px; font-weight: bold; fill: #2c3e50; }
        .module-title { font-family: Arial, sans-serif; font-size: 16px; font-weight: 600; fill: #2c3e50; }
        .module-description { font-family: Arial, sans-serif; font-size: 12px; font-weight: normal; fill: #7f8c8d; }
        .module-link { font-family: Arial, sans-serif; font-size: 12px; font-weight: normal; fill: #3498db; }
        .module-link:hover { fill: #2980b9; }
        .module-tag { font-family: Arial, sans-serif; font-size: 11px; font-weight: 500; fill: #2980b9; }
        .module-tag:hover { fill: #1a5999; }
                        .version-text { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; fill: #2c3e50; }
                .database-name-text { font-family: Arial, sans-serif; font-size: 20px; font-weight: 900; fill: #34495e; letter-spacing: 1.5px; }
                        /* Enhanced Color-Coded Constraint Tags */
                .constraint-tag-bg { transition: fill 0.2s ease, stroke 0.2s ease; }
                .constraint-tag-text { font-family: 'SF Mono', 'Monaco', 'Consolas', monospace; font-size: 11px; font-weight: 500; transition: fill 0.2s ease, font-weight 0.2s ease; }
                
                                /* Default value tags - Orange border */
                .tag-default { fill: rgba(230, 126, 34, 0.15); stroke: #e67e22; stroke-width: 0.4; }
                .tag-default-text { fill: #d35400; font-weight: 600; font-size: 11px; }
                
                /* App/JSON field name tags - Green border (both use same styling) */
                .tag-app { fill: rgba(46, 204, 113, 0.15); stroke: #27ae60; stroke-width: 0.4; }
                .tag-app-text { fill: #1e8449; font-weight: 600; font-size: 11px; }
                
                /* Constraint tags - Blue border */
                .tag-constraint { fill: rgba(52, 152, 219, 0.15); stroke: #3498db; stroke-width: 0.4; }
                .tag-constraint-text { fill: #2980b9; font-weight: 600; font-size: 11px; }
                
                /* FK tags - Medium purple for legible visual hierarchy */
                .tag-fk { fill: rgba(168, 85, 205, 0.15); stroke: #a855cd; stroke-width: 0.4; }
                .tag-fk-text { fill: #a855cd; font-weight: 600; font-size: 11px; }
                
                /* Encrypted tags - Red border (matches sensitive fields) */
                .tag-encrypted { fill: rgba(255, 71, 87, 0.15); stroke: #ff4757; stroke-width: 0.4; }
                .tag-encrypted-text { fill: #c0392b; font-weight: 600; font-size: 11px; }
                
                /* System/Auto tags - Dark gray border */
                .tag-system { fill: rgba(52, 73, 94, 0.15); stroke: #34495e; stroke-width: 0.6; }
                .tag-system-text { fill: #999999; font-weight: 600; font-size: 11px; }
                
                /* Enhanced hover effects for all tag types */
                .constraint-tag:hover .tag-default, 
                .constraint-tag:hover .tag-app,
                .constraint-tag:hover .tag-constraint,
                .constraint-tag:hover .tag-fk,
                .constraint-tag:hover .tag-encrypted,
                .constraint-tag:hover .tag-system { fill: rgba(52, 73, 94, 0.9); stroke: #2c3e50; stroke-width: 1.5; }
                
                .constraint-tag:hover .tag-default-text,
                .constraint-tag:hover .tag-app-text,
                .constraint-tag:hover .tag-constraint-text,
                .constraint-tag:hover .tag-fk-text,
                .constraint-tag:hover .tag-encrypted-text,
                .constraint-tag:hover .tag-system-text { fill: white; font-weight: bold; }
        .constraint-tag:hover { cursor: none; }
        .browser-message { opacity: 1; transition: opacity 0.3s ease; }
        .browser-message:hover { opacity: 0.6; }
        .overview-label { font-family: Arial, sans-serif; font-size: 12px; font-weight: bold; fill: #2c3e50; }
        .overview-text { font-family: Arial, sans-serif; font-size: 12px; fill: #34495e; }
        .overview-section { font-family: Arial, sans-serif; font-size: 12px; font-weight: bold; fill: #2980b9; }
        .overview-detail { font-family: Arial, sans-serif; font-size: 11px; fill: #34495e; }
        </style>
        
        """
        
        // Add background if specified
        if let bgColor = backgroundColor {
            svg += """
            <rect x="0" y="0" width="\(layout.totalWidth)" height="\(layout.totalHeight)" fill="\(bgColor)" opacity="1"/>
            
            """
        }
        
        // Add browser interactivity message
        svg += generateBrowserMessage(layout: layout)
        
        // Generate architectural overview if available
        if let overview = architecturalOverview {
            svg += generateArchitecturalOverview(overview, layout: layout)
        }
        
        // Generate module headers and swimlanes
        svg += generateModuleHeaders(layout: layout)
        svg += generateSwimlanes(layout: layout)
        
        // Generate entities organized by module
        for moduleInfo in entitiesByModule {
            // Generate standard entities first
            for entity in moduleInfo.standardEntities {
            svg += generateEntityBox(entity: entity, layout: layout)
            }
            // Then embedded entities
            for entity in moduleInfo.embeddedEntities {
                svg += generateEntityBox(entity: entity, layout: layout)
            }
        }
        
        // Generate version display
        svg += generateVersionDisplay(layout: layout)
        
        // Generate relationships legend
        if !allRelationships.isEmpty {
            svg += generateRelationshipsLegend(relationships: allRelationships, layout: layout)
        }
        
        // Generate color legend
        svg += generateColorLegend(layout: layout)
        
        // Generate attribution
        svg += generateAttribution(layout: layout)
        
        svg += "</svg>"
        return svg
    }
    
    private func getAllEntities() -> [Entity] {
        var entities: [Entity] = []
        for moduleSection in document.schemaDefinition.moduleSections {
            entities.append(contentsOf: moduleSection.entities)
        }
        // Sort entities alphabetically by name for better scanning
        return entities.sorted { $0.name < $1.name }
    }
    
    private func getEntitiesByModule() -> [(moduleName: String, moduleDescription: String?, standardEntities: [Entity], embeddedEntities: [Entity])] {
        return document.schemaDefinition.moduleSections.map { moduleSection in
            let standardEntities = moduleSection.entities.filter { $0.type == .standard }.sorted { $0.name < $1.name }
            let embeddedEntities = moduleSection.entities.filter { $0.type == .embedded }.sorted { $0.name < $1.name }
            return (moduleName: moduleSection.name, moduleDescription: moduleSection.description, standardEntities: standardEntities, embeddedEntities: embeddedEntities)
        }
    }

    
    private func getAllRelationships() -> [Relationship] {
        return document.relationshipDefinitions?.relationships ?? []
    }
    
    private func generateEntityBox(entity: Entity, layout: SVGLayout) -> String {
        guard let position = layout.entityPositions[entity.name] else {
            return ""
        }
        
        let headerHeight = 35
        let fieldHeight = 18
        let padding = 12
        
        // Determine styles based on entity type
        let isEmbedded = entity.type == .embedded
        let entityBoxClass = isEmbedded ? "embedded-entity-box" : "entity-box"
        let entityHeaderClass = isEmbedded ? "embedded-entity-header" : "entity-header"
        let entityTitleClass = isEmbedded ? "embedded-entity-title" : "entity-title"
        let fieldTextClass = isEmbedded ? "embedded-field-text" : "field-text"
        let commentClass = isEmbedded ? "embedded-entity-comment" : "entity-comment"
        
        var svg = """
        <g id="\(entity.name)">
        <!-- Entity container -->
        <rect x="\(position.x)" y="\(position.y)" width="\(position.width)" height="\(position.height)" class="\(entityBoxClass)" rx="8"/>
        
        <!-- Entity header -->
        <rect x="\(position.x)" y="\(position.y)" width="\(position.width)" height="\(headerHeight)" class="\(entityHeaderClass)" rx="8"/>
        
        <!-- Entity comment above title -->
        """
        
        if let comment = entity.comment {
            svg += """
            <text x="\(position.x + position.width/2)" y="\(position.y + 12)" class="\(commentClass)" text-anchor="middle">\(xmlEscape(comment))</text>
            
            """
        }
        
        svg += """
        <!-- Entity title -->
        <text x="\(position.x + position.width/2)" y="\(position.y + (entity.comment != nil ? 27 : 22))" class="\(entityTitleClass)" text-anchor="middle">\(xmlEscape(entity.name))</text>
        
        """
        
        // Generate ALL fields (no truncation)
        let startY = position.y + headerHeight + 15
        for (index, field) in entity.fields.enumerated() {
            let fieldY = startY + (index * fieldHeight)
            let fieldText = formatFieldText(field: field)
            let fieldClass = getFieldClass(field: field, isEmbedded: isEmbedded)
            
            // Check if this is a foreign key field for navigation
            if let referencedEntity = getForeignKeyReference(field: field) {
                let tooltipText = referencedEntity
                let tooltipPadding = 8
                let tooltipHeight = 20
                let tooltipWidth = max(tooltipText.count * 8 + (tooltipPadding * 2), 60)  // Better width calculation
                
                // Center tooltip horizontally relative to the field
                let fieldTextWidth = fieldText.count * 7  // Approximate field text width
                let fieldCenterX = position.x + padding + (fieldTextWidth / 2)
                var tooltipX = fieldCenterX - (tooltipWidth / 2)
                
                // Ensure tooltip doesn't go outside entity boundaries
                let minX = position.x + 5
                let maxX = position.x + position.width - tooltipWidth - 5
                tooltipX = max(minX, min(tooltipX, maxX))
                
                let tooltipY = fieldY - tooltipHeight - 8  // More space above the field
                
                // Text positioning - centered within rectangle
                let textCenterX = tooltipX + (tooltipWidth / 2)
                let textCenterY = tooltipY + (tooltipHeight / 2) + 4  // Adjust for SVG text baseline
                
                svg += """
                <g class="field-with-tooltip">
                    <text x="\(position.x + padding)" y="\(fieldY)" 
                          class="\(fieldTextClass) \(fieldClass) interactive-field"
                          onclick="document.getElementById('\(referencedEntity)').scrollIntoView({behavior:'smooth'}); var rects = document.getElementById('\(referencedEntity)').getElementsByTagName('rect'); for(var i=0; i&lt;rects.length; i++) { rects[i].style.stroke='#9b59b6'; rects[i].style.strokeWidth='4'; } setTimeout(() => { for(var i=0; i&lt;rects.length; i++) { rects[i].style.stroke=''; rects[i].style.strokeWidth=''; } }, 1500);" 
                          style="cursor: pointer;">\(xmlEscape(fieldText))</text>
                    \(generateConstraintTags(field: field, x: position.x + padding, y: fieldY, fieldText: fieldText))
                    <g class="tooltip-group">
                        <rect x="\(tooltipX)" y="\(tooltipY)" width="\(tooltipWidth)" height="\(tooltipHeight)" class="tooltip-bg"/>
                        <text x="\(textCenterX)" y="\(textCenterY)" text-anchor="middle" class="tooltip-text">\(xmlEscape(tooltipText))</text>
                    </g>
                </g>
                
                """
            } else if let embeddedEntity = getEmbeddedEntityReference(field: field) {
                let tooltipText = embeddedEntity
                let tooltipPadding = 8
                let tooltipHeight = 20
                let tooltipWidth = max(tooltipText.count * 8 + (tooltipPadding * 2), 60)  // Better width calculation
                
                // Center tooltip horizontally relative to the field
                let fieldTextWidth = fieldText.count * 7  // Approximate field text width
                let fieldCenterX = position.x + padding + (fieldTextWidth / 2)
                var tooltipX = fieldCenterX - (tooltipWidth / 2)
                
                // Ensure tooltip doesn't go outside entity boundaries
                let minX = position.x + 5
                let maxX = position.x + position.width - tooltipWidth - 5
                tooltipX = max(minX, min(tooltipX, maxX))
                
                let tooltipY = fieldY - tooltipHeight - 8  // More space above the field
                
                // Text positioning - centered within rectangle
                let textCenterX = tooltipX + (tooltipWidth / 2)
                let textCenterY = tooltipY + (tooltipHeight / 2) + 4  // Adjust for SVG text baseline
                
                svg += """
                <g class="field-with-tooltip">
                    <text x="\(position.x + padding)" y="\(fieldY)" 
                          class="\(fieldTextClass) \(fieldClass) interactive-field"
                          onclick="document.getElementById('\(embeddedEntity)').scrollIntoView({behavior:'smooth'}); var rects = document.getElementById('\(embeddedEntity)').getElementsByTagName('rect'); for(var i=0; i&lt;rects.length; i++) { rects[i].style.stroke='#8e44ad'; rects[i].style.strokeWidth='4'; } setTimeout(() => { for(var i=0; i&lt;rects.length; i++) { rects[i].style.stroke=''; rects[i].style.strokeWidth=''; } }, 1500);" 
                          style="cursor: pointer;">\(xmlEscape(fieldText))</text>
                    \(generateConstraintTags(field: field, x: position.x + padding, y: fieldY, fieldText: fieldText))
                    <g class="tooltip-group">
                        <rect x="\(tooltipX)" y="\(tooltipY)" width="\(tooltipWidth)" height="\(tooltipHeight)" class="tooltip-bg"/>
                        <text x="\(textCenterX)" y="\(textCenterY)" text-anchor="middle" class="tooltip-text">\(xmlEscape(tooltipText))</text>
                    </g>
                </g>
                
                """
            } else {
                svg += """
                <text x="\(position.x + padding)" y="\(fieldY)" class="\(fieldTextClass) \(fieldClass)">\(xmlEscape(fieldText))</text>
                \(generateConstraintTags(field: field, x: position.x + padding, y: fieldY, fieldText: fieldText))
                """
            }
        }
        
        svg += "</g>\n"
        return svg
    }
    
    private func getFieldClass(field: Field, isEmbedded: Bool = false) -> String {
        let prefix = isEmbedded ? "embedded-" : ""
        
        // Check for embedded entity field first (highest priority for color)
        if case .embeddedEntity(_) = field.dataType {
            return "\(prefix)embedded-entity-field"
        } else if case .relationshipArray(_, _) = field.dataType {
            return "\(prefix)embedded-entity-field"
        } else if isEmbeddedEntityReference(field: field) {
            return "\(prefix)embedded-entity-field"
        } else if field.constraints.contains(where: { $0.name.hasPrefix("FK") }) {
            return "\(prefix)foreign-key"
        } else if field.prefixes.contains(.sensitive) {
            return "\(prefix)sensitive"
        } else if field.prefixes.contains(.required) {
            return "\(prefix)required"
        } else if field.prefixes.contains(.indexed) {
            return "\(prefix)indexed"
        } else {
            return "\(prefix)optional"
        }
    }
    
    private func isEmbeddedEntityReference(field: Field) -> Bool {
        let allEntities = getAllEntities()
        let embeddedEntityNames = allEntities.filter { $0.type == .embedded }.map { $0.name }
        
        // Check if field data type references an embedded entity
        switch field.dataType {
        case .simple(let typeName):
            return embeddedEntityNames.contains(typeName)
        case .relationshipArray(let typeName, _):
            return embeddedEntityNames.contains(typeName)
        case .array(let innerType):
            if case .simple(let innerTypeName) = innerType {
                return embeddedEntityNames.contains(innerTypeName)
            }
            return false
        default:
            return false
        }
    }
    
    private func getForeignKeyReference(field: Field) -> String? {
        // Check if field has a foreign key constraint
        for constraint in field.constraints {
            if constraint.name == "FK" {
                // Extract referenced entity name from constraint value
                // Format: EntityName.fieldName
                if let value = constraint.value,
                   let dotIndex = value.firstIndex(of: ".") {
                    let entityName = String(value[..<dotIndex])
                    return entityName
                }
            }
        }
        return nil
    }
    
    private func getEmbeddedEntityReference(field: Field) -> String? {
        let allEntities = getAllEntities()
        let embeddedEntityNames = allEntities.filter { $0.type == .embedded }.map { $0.name }
        
        // Check if field data type references an embedded entity
        switch field.dataType {
        case .simple(let typeName):
            return embeddedEntityNames.contains(typeName) ? typeName : nil
        case .embeddedEntity(let typeName):
            return typeName
        case .relationshipArray(let typeName, _):
            return embeddedEntityNames.contains(typeName) ? typeName : nil
        case .array(let innerType):
            if case .simple(let innerTypeName) = innerType {
                return embeddedEntityNames.contains(innerTypeName) ? innerTypeName : nil
            } else if case .embeddedEntity(let innerTypeName) = innerType {
                return innerTypeName
            }
            return nil
        default:
            return nil
        }
    }
    
    private func formatFieldText(field: Field) -> String {
        let prefixText = field.prefixes.map { $0.rawValue }.joined()
        let nameText = field.names.joined(separator: ", ")
        let typeText = formatDataType(field.dataType)
        
        return "\(prefixText) \(nameText): \(typeText)"
    }
    
    private func generateConstraintTags(field: Field, x: Int, y: Int, fieldText: String) -> String {
        guard !field.constraints.isEmpty else { return "" }
        
        let fieldTextWidth = fieldText.count * 7 // Approximate width
        var tagX = x + fieldTextWidth + 8 // Start after field text with some padding
        var tagSvg = ""
        
        for constraint in field.constraints {
            let (displayText, tagCategory) = getSmartDisplayText(constraint: constraint)
            
            // Special handling for FK tags - smaller font and reduced padding
            let isFKTag = displayText.starts(with: "fk -") || displayText == "fk"
            let isEnumTag = constraint.name.lowercased() == "enum"
            let bgClass: String
            let textClass: String
            let tagWidth: Int
            let tagHeight: Int
            
            if isFKTag {
                // FK tag optimization: 10px font, minimal padding
                let baseCharWidth = 5  // Tighter character width for 10px font
                let padding = 2        // Minimal padding for FK tags
                let minWidth = 16      // Minimum width for 10px readability
                bgClass = "tag-fk"
                textClass = "tag-fk-text"
                tagWidth = max(displayText.count * baseCharWidth + padding, minWidth)
                tagHeight = 12
            } else {
                // Regular constraint tags: 11px font
                let baseCharWidth = 7  // Character width for 11px font
                let padding = 6        // Standard padding
                let minWidth = 22      // Minimum width for 11px readability
                let (bg, text) = getTagClasses(category: tagCategory)
                bgClass = bg
                textClass = text
                tagWidth = max(displayText.count * baseCharWidth + padding, minWidth)
                tagHeight = 12
            }
            
            // Add tooltip for enum tags
            if isEnumTag, let enumValue = constraint.value {
                let tooltipText = "Valid values: \(enumValue)"
                let tooltipPadding = 8
                let tooltipHeight = 20
                let tooltipWidth = max(tooltipText.count * 8 + (tooltipPadding * 2), 80)
                
                let tooltipX = tagX + (tagWidth / 2) - (tooltipWidth / 2)
                let tooltipY = y - 35 // Above the tag
                let textCenterX = tooltipX + (tooltipWidth / 2)
                let textCenterY = tooltipY + (tooltipHeight / 2) + 4
                
                tagSvg += """
                <g class="constraint-tag-with-tooltip">
                    <rect x="\(tagX)" y="\(y - 9)" width="\(tagWidth)" height="\(tagHeight)" 
                          class="\(bgClass)" rx="3"/>
                    <text x="\(tagX + tagWidth/2)" y="\(y - 3)" class="\(textClass)" 
                          text-anchor="middle" dominant-baseline="central">\(xmlEscape(displayText))</text>
                    
                    <g class="tooltip-group">
                        <rect x="\(tooltipX)" y="\(tooltipY)" width="\(tooltipWidth)" height="\(tooltipHeight)" class="tooltip-bg"/>
                        <text x="\(textCenterX)" y="\(textCenterY)" text-anchor="middle" class="tooltip-text">\(xmlEscape(tooltipText))</text>
                    </g>
                </g>
                
                """
            } else {
                tagSvg += """
                <g class="constraint-tag">
                    <rect x="\(tagX)" y="\(y - 9)" width="\(tagWidth)" height="\(tagHeight)" 
                          class="\(bgClass)" rx="3"/>
                    <text x="\(tagX + tagWidth/2)" y="\(y - 3)" class="\(textClass)" 
                          text-anchor="middle" dominant-baseline="central">\(xmlEscape(displayText))</text>
                </g>
                
                """
            }
            
            tagX += tagWidth + 3 // Compact spacing for tighter tags
        }
        
        return tagSvg
    }
    
    private func getSmartDisplayText(constraint: Constraint) -> (text: String, category: TagCategory) {
        let constraintName = constraint.name.lowercased()
        
        // Handle different constraint types with smart transformations
        switch constraintName {
        case "default":
            if let value = constraint.value {
                if value == "CURRENT_TIMESTAMP" {
                    return ("â€¢ now", .system)
                } else {
                    // Show full default values (no truncation for strings like 'pending_approval')
                    return (value, .default)
                }
            }
            return ("default", .default)
            
        case "app":
            if let value = constraint.value {
                return ("app: \(value)", .app)
            }
            return ("app", .app)
            
        case "json":
            if let value = constraint.value {
                return ("json: \(value)", .app)  // Use .app category for same green styling
            }
            return ("json", .app)
            
        case "fk":
            if let value = constraint.value,
               let dotIndex = value.firstIndex(of: ".") {
                let entityName = String(value[..<dotIndex])
                // Always show full FK entity name with optimized spacing
                return ("fk - \(entityName)", .constraint)
            }
            return ("fk", .constraint)
            
        case "enum":
            return ("enum", .constraint)
            
        case "pk":
            return ("pk", .constraint)
            
        case "index", "idx":
            return ("idx", .constraint)
            
        case "unique", "uk":
            return ("uk", .constraint)
            
        case "encrypted":
            return ("enc", .encrypted)
            
        case "system":
            return ("sys", .system)
            
        case "auto", "auto_increment":
            return ("auto", .system)
            
        default:
            // Other constraints - show as lowercase
            if let value = constraint.value {
                return ("\(constraintName): \(value)", .constraint)
            }
            return (constraintName, .constraint)
        }
    }
    
    private func getTagClasses(category: TagCategory) -> (bgClass: String, textClass: String) {
        switch category {
        case .default:
            return ("tag-default", "tag-default-text")
        case .app:
            return ("tag-app", "tag-app-text")
        case .constraint:
            return ("tag-constraint", "tag-constraint-text")
        case .encrypted:
            return ("tag-encrypted", "tag-encrypted-text")
        case .system:
            return ("tag-system", "tag-system-text")
        }
    }
    
    enum TagCategory {
        case `default`    // Orange - default values
        case app         // Green - app/JSON field names (both use same styling)
        case constraint  // Blue - database constraints
        case encrypted   // Red - encrypted/sensitive attributes
        case system      // Gray - system/auto values
    }
    
    private func formatDataType(_ dataType: DataType) -> String {
        switch dataType {
        case .simple(let type):
            return type
        case .parametric(let type, let params):
            return "\(type)(\(params.joined(separator: ", ")))"
        case .array(let innerType):
            return "[\(formatDataType(innerType))]"
        case .jsonObject:
            return "JSON"
        case .relationshipArray(let type, _):
            return "[\(type)]"
        case .embeddedEntity(let type):
            return type
        }
    }
    
    private func generateModuleHeaders(layout: SVGLayout) -> String {
        var svg = ""
        
        for header in layout.moduleHeaders {
            let hasDescription = header.description != nil && !header.description!.isEmpty
            let barHeight = hasDescription ? 40 : 32
            let moduleId = "module-\(header.name.lowercased())"
            
            svg += """
            <g class="module-header" id="\(moduleId)">
                <rect x="\(header.x)" y="\(header.y)" width="4" height="\(barHeight)" 
                      fill="#3498db" rx="2"/>
                <text x="\(header.x + 20)" y="\(header.y + 21)" 
                      class="module-title">\(xmlEscape(header.name))</text>
            """
            
            if let description = header.description, !description.isEmpty {
                svg += """
                <text x="\(header.x + 20)" y="\(header.y + 36)" 
                      class="module-description">\(xmlEscape(description))</text>
                """
            }
            
            svg += """
            </g>
            
            """
        }
        
        return svg
    }
    
    private func generateSwimlanes(layout: SVGLayout) -> String {
        var svg = ""
        
        for swimlane in layout.swimlanes {
            svg += """
            <line x1="\(swimlane.x)" y1="\(swimlane.y)" x2="\(swimlane.x + swimlane.width)" y2="\(swimlane.y)" 
                  stroke="#bdc3c7" stroke-width="2" stroke-dasharray="10,5" opacity="0.6"/>
            
            """
        }
        
        return svg
    }
    
    // MARK: - Layout Calculation
    
    private func calculateModularLayout(entitiesByModule: [(moduleName: String, moduleDescription: String?, standardEntities: [Entity], embeddedEntities: [Entity])], relationships: [Relationship], architecturalOverview: ArchitecturalOverview?) -> SVGLayout {
        var layout = SVGLayout()
        let basePadding = 50 // Increased to make room for browser message
        let entityPadding = 25
        let legendPadding = 30
        let maxEntitiesPerRow = 5
        let moduleHeaderHeight = 50  // Increased to accommodate descriptions
        let swimlaneSpacing = 30
        
        // Calculate architectural overview height (but don't use it for entity positioning)
        var overviewHeight = 0
        if let overview = architecturalOverview {
            overviewHeight = calculateOverviewHeight(overview: overview)
            layout.overviewHeight = overviewHeight
        }
        
        var entityPositions: [String: EntityPosition] = [:]
        var moduleHeaders: [(x: Int, y: Int, width: Int, name: String, description: String?)] = []
        var swimlanes: [(x: Int, y: Int, width: Int, height: Int)] = []
        
        let currentX = basePadding
        var currentY = basePadding
        layout.entitiesStartY = currentY
        var maxModuleWidth = 0
        
        for (index, moduleInfo) in entitiesByModule.enumerated() {
            let moduleStartY = currentY
            
            // Add module header
            currentY += moduleHeaderHeight
            
            // Process standard entities first
            var moduleMaxX = currentX
            let (standardPositions, standardEndY, standardMaxX) = layoutEntitiesInModule(
                entities: moduleInfo.standardEntities,
                startX: currentX,
                startY: currentY,
                maxEntitiesPerRow: maxEntitiesPerRow,
                entityPadding: entityPadding
            )
            entityPositions.merge(standardPositions) { _, new in new }
            currentY = standardEndY
            moduleMaxX = max(moduleMaxX, standardMaxX)
            
            // Add small gap between standard and embedded entities if both exist
            if !moduleInfo.standardEntities.isEmpty && !moduleInfo.embeddedEntities.isEmpty {
                currentY += entityPadding / 2
            }
            
            // Process embedded entities
            let (embeddedPositions, embeddedEndY, embeddedMaxX) = layoutEntitiesInModule(
                entities: moduleInfo.embeddedEntities,
                startX: currentX,
                startY: currentY,
                maxEntitiesPerRow: maxEntitiesPerRow,
                entityPadding: entityPadding
            )
            entityPositions.merge(embeddedPositions) { _, new in new }
            currentY = embeddedEndY
            moduleMaxX = max(moduleMaxX, embeddedMaxX)
            
            // Store module header info
            let moduleWidth = moduleMaxX - currentX + basePadding
            moduleHeaders.append((x: currentX, y: moduleStartY, width: moduleWidth, name: moduleInfo.moduleName, description: moduleInfo.moduleDescription))
            maxModuleWidth = max(maxModuleWidth, moduleWidth)
            
            // Add swimlane (except for last module)
            if index < entitiesByModule.count - 1 {
                currentY += swimlaneSpacing
                swimlanes.append((x: basePadding, y: currentY - swimlaneSpacing/2, width: moduleMaxX - basePadding + basePadding, height: 1))
            }
        }
        
        // Store layout information
        layout.entityPositions = entityPositions
        layout.moduleHeaders = moduleHeaders
        layout.swimlanes = swimlanes
        
        // Calculate entities area dimensions
        let maxX = max(entityPositions.values.map { $0.x + $0.width }.max() ?? 0, maxModuleWidth)
        let entitiesBottomY = currentY
        
        // Calculate version display position
        let versionHeight = 30
        let versionX = maxX + legendPadding
        let versionY = basePadding
        let versionWidth = 400
        
        // Calculate legend dimensions and position (moved down to align with first entity)
        let legendWidth = 400
        let legendHeight = calculateLegendHeight(relationships: relationships)
        let legendX = maxX + legendPadding
        let firstEntityY = entityPositions.values.map { $0.y }.min() ?? basePadding
        let legendY = firstEntityY
        
        // Calculate overview position (below legend, same width)
        let overviewX = legendX
        let overviewY = legendY + legendHeight + 20  // 20px gap below legend
        let overviewWidth = legendWidth  // Same width as legend
        
        // Calculate color legend position (below overview, same width)
        let colorLegendHeight = 240  // Fits all field types and attribute colors sections
        let colorLegendX = overviewX
        let colorLegendY = overviewY + (overviewHeight - 20) + 20  // 20px gap below overview (accounting for overview height adjustment)
        let colorLegendWidth = overviewWidth  // Same width as overview
        
        // Calculate attribution position (below color legend, same width)
        let attributionHeight = 50  // Fixed height for attribution
        let attributionX = colorLegendX
        let attributionY = colorLegendY + colorLegendHeight + 20  // 20px gap below color legend (consistent with other gaps)
        let attributionWidth = colorLegendWidth  // Same width as color legend
        
        // Set layout properties
        layout.entityPositions = entityPositions
        layout.versionX = versionX
        layout.versionY = versionY
        layout.versionWidth = versionWidth
        layout.versionHeight = versionHeight
        layout.legendX = legendX
        layout.legendY = legendY
        layout.legendWidth = legendWidth
        layout.legendHeight = legendHeight
        layout.overviewX = overviewX
        layout.overviewY = overviewY
        layout.overviewWidth = overviewWidth
        layout.colorLegendX = colorLegendX
        layout.colorLegendY = colorLegendY
        layout.colorLegendWidth = colorLegendWidth
        layout.colorLegendHeight = colorLegendHeight
        layout.attributionX = attributionX
        layout.attributionY = attributionY
        layout.attributionWidth = attributionWidth
        layout.attributionHeight = attributionHeight
        layout.totalWidth = max(maxX + basePadding, legendX + legendWidth + basePadding)
        layout.totalHeight = max(entitiesBottomY + basePadding, 
                                max(legendY + legendHeight + basePadding, 
                                    max(overviewY + overviewHeight + basePadding,
                                        max(colorLegendY + colorLegendHeight + basePadding,
                                            attributionY + attributionHeight + basePadding))))
        
        return layout
    }
    
    private func layoutEntitiesInModule(entities: [Entity], startX: Int, startY: Int, maxEntitiesPerRow: Int, entityPadding: Int) -> ([String: EntityPosition], Int, Int) {
        var entityPositions: [String: EntityPosition] = [:]
        var currentX = startX
        var currentY = startY
        var currentRowHeight = 0
        var entitiesInCurrentRow = 0
        var maxX = startX
        
        for entity in entities {
            let dimensions = calculateEntityDimensions(entity: entity)
            
            // Check if we need a new row
            if entitiesInCurrentRow >= maxEntitiesPerRow {
                currentX = startX
                currentY += currentRowHeight + entityPadding
                currentRowHeight = 0
                entitiesInCurrentRow = 0
            }
            
            let position = EntityPosition(
                x: currentX,
                y: currentY,
                width: dimensions.width,
                height: dimensions.height
            )
            entityPositions[entity.name] = position
            
            // Update for next entity
            currentX += dimensions.width + entityPadding
            currentRowHeight = max(currentRowHeight, dimensions.height)
            entitiesInCurrentRow += 1
            maxX = max(maxX, currentX)
        }
        
        let finalY = entities.isEmpty ? startY : currentY + currentRowHeight
        return (entityPositions, finalY, maxX)
    }
    
    private func calculateEntityDimensions(entity: Entity) -> (width: Int, height: Int) {
        let headerHeight = 35
        let fieldHeight = 18
        let padding = 12
        let minWidth = 240
        
        // Calculate width based on longest field text
        let maxFieldWidth = entity.fields.map { field in
            let fieldText = formatFieldText(field: field)
            return fieldText.count * 7 + padding * 2 // Approximate character width
        }.max() ?? 0
        
        let titleWidth = entity.name.count * 10 + padding * 2
        let commentWidth = entity.comment != nil ? (entity.comment!.count * 7 + padding * 2) : 0
        let width = max(minWidth, max(maxFieldWidth, max(titleWidth, commentWidth)))
        
        // Calculate height based on field count (comment is now in header area)
        let fieldsHeight = entity.fields.count * fieldHeight
        let height = headerHeight + fieldsHeight + 30 // Extra padding
        
        return (width: width, height: height)
    }
    
    private func calculateLegendHeight(relationships: [Relationship]) -> Int {
        if relationships.isEmpty {
            return 0
        }
        
        let headerHeight = 36
        let rowHeight = 20
        let padding = 20
        
        return headerHeight + (relationships.count * rowHeight) + padding
    }
    
    private func calculateOverviewHeight(overview: ArchitecturalOverview) -> Int {
        let headerHeight = 45
        let lineHeight = 18
        var totalLines = 2 // Title and padding
        let maxCharsPerLine = 70 // Same as used in text wrapping
        
        if overview.purpose != nil { totalLines += 1 }
        if overview.domain != nil { totalLines += 1 }
        if overview.architecturePattern != nil { totalLines += 1 }
        
        // Account for module tag cloud (after pattern)
        let moduleList = getModuleList()
        if !moduleList.isEmpty {
            totalLines += 1 // "Modules:" label
            // More accurate estimation: use almost full width (380px available, starting at 85px offset)
            let avgModuleWidth = 65 // More realistic average including shorter names + spacing
            let availableWidth = 380 - 85 // Full width minus label offset
            let modulesPerLine = max(1, availableWidth / avgModuleWidth)
            let tagCloudLines = (moduleList.count + modulesPerLine - 1) / modulesPerLine
            totalLines += tagCloudLines
            totalLines += 1 // Extra spacing after tag cloud
        }
        
        if !overview.dataDistribution.isEmpty {
            totalLines += 1 // Section header
            for distribution in overview.dataDistribution.prefix(3) {
                let wrappedLines = wrapText(distribution, maxCharsPerLine: maxCharsPerLine)
                totalLines += wrappedLines.count
            }
        }
        
        if !overview.keyFeatures.isEmpty {
            totalLines += 1 // Section header
            for feature in overview.keyFeatures.prefix(3) {
                let wrappedLines = wrapText(feature, maxCharsPerLine: maxCharsPerLine)
                totalLines += wrappedLines.count
            }
        }
        
        if !overview.moduleBreakdown.isEmpty {
            totalLines += 1 // Section header
            for module in overview.moduleBreakdown.prefix(4) {
                let wrappedLines = wrapText(module, maxCharsPerLine: maxCharsPerLine)
                totalLines += wrappedLines.count
            }
        }
        
        return headerHeight + (totalLines * lineHeight) + 35 // Extra padding for features + title spacing
    }
    
    private func generateVersionDisplay(layout: SVGLayout) -> String {
        let x = layout.versionX
        let y = layout.versionY
        let width = layout.versionWidth
        let height = layout.versionHeight
        
        let version = document.yamlHeader?.version ?? "Unknown"
        let dbname = document.yamlHeader?.dbname
        
        var versionDisplay = """
        <g class="version-display">
        
        """
        
        if let dbname = dbname {
            // Database name at the top
            versionDisplay += """
            <text x="\(x + width/2)" y="\(y + 8)" class="database-name-text" text-anchor="middle">\(xmlEscape(dbname))</text>
            
            """
            
            // Version text below database name
            versionDisplay += """
            <text x="\(x + width/2)" y="\(y + height/2 + 12)" class="version-text" text-anchor="middle">\(DBSoupSVGGenerator.schemaVersionLabel)\(xmlEscape(version))</text>
            
            """
        } else {
            // Only version text (centered as before)
            versionDisplay += """
            <text x="\(x + width/2)" y="\(y + height/2 + 4)" class="version-text" text-anchor="middle">\(DBSoupSVGGenerator.schemaVersionLabel)\(xmlEscape(version))</text>
            
            """
        }
        
        versionDisplay += """
        </g>
        
        """
        
        return versionDisplay
    }
    
    private func generateRelationshipsLegend(relationships: [Relationship], layout: SVGLayout) -> String {
        guard !relationships.isEmpty else { return "" }
        
        let x = layout.legendX
        let y = layout.legendY
        let width = layout.legendWidth
        let height = layout.legendHeight
        let headerHeight = 36
        let rowHeight = 20
        let padding = 10
        
        var legend = """
        <g class="legend">
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(height)" class="legend-box" rx="8"/>
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(headerHeight)" class="legend-header" rx="8"/>
            <text x="\(x + width/2)" y="\(y + headerHeight/2 + 6)" class="legend-title" text-anchor="middle">Relationships</text>
            <line x1="\(x + 8)" y1="\(y + headerHeight)" x2="\(x + width - 8)" y2="\(y + headerHeight)" class="header-separator"/>
        
        """
        
        // Column headers
        let col1X = x + padding
        let col2X = x + width/3
        let col3X = x + 2*width/3
        let headerY = y + headerHeight + 15
        
        legend += """
            <text x="\(col1X)" y="\(headerY)" class="legend-header-text">From Entity</text>
            <text x="\(col2X)" y="\(headerY)" class="legend-header-text">To Entity</text>
            <text x="\(col3X)" y="\(headerY)" class="legend-header-text">Relationship</text>
        
        """
        
        // Header separator line
        legend += """
            <line x1="\(x + 5)" y1="\(headerY + 5)" x2="\(x + width - 5)" y2="\(headerY + 5)" class="legend-row"/>
        
        """
        
        // Relationship rows
        for (index, relationship) in relationships.enumerated() {
            let rowY = headerY + 15 + (index * rowHeight)
            
            // Add alternating row background for even rows
            if index % 2 == 0 {
                let rowBgY = rowY - 12
                legend += """
                    <rect x="\(x + 5)" y="\(rowBgY)" width="\(width - 10)" height="\(rowHeight)" class="legend-row-bg" rx="3"/>
                
                """
            }
            
            let relationshipText = formatRelationshipForLegend(relationship)
            
            legend += """
                <text x="\(col1X)" y="\(rowY)" class="legend-text interactive-field" 
                      onclick="document.getElementById('\(relationship.fromEntity)').scrollIntoView({behavior:'smooth'}); var rects = document.getElementById('\(relationship.fromEntity)').getElementsByTagName('rect'); for(var i=0; i&lt;rects.length; i++) { rects[i].style.stroke='#9b59b6'; rects[i].style.strokeWidth='4'; } setTimeout(() => { for(var i=0; i&lt;rects.length; i++) { rects[i].style.stroke=''; rects[i].style.strokeWidth=''; } }, 1500);"
                      style="cursor: pointer;">\(xmlEscape(relationship.fromEntity))</text>
                <text x="\(col2X)" y="\(rowY)" class="legend-text interactive-field" 
                      onclick="document.getElementById('\(relationship.toEntity)').scrollIntoView({behavior:'smooth'}); var rects = document.getElementById('\(relationship.toEntity)').getElementsByTagName('rect'); for(var i=0; i&lt;rects.length; i++) { rects[i].style.stroke='#9b59b6'; rects[i].style.strokeWidth='4'; } setTimeout(() => { for(var i=0; i&lt;rects.length; i++) { rects[i].style.stroke=''; rects[i].style.strokeWidth=''; } }, 1500);"
                      style="cursor: pointer;">\(xmlEscape(relationship.toEntity))</text>
                <text x="\(col3X)" y="\(rowY)" class="legend-text">\(xmlEscape(relationshipText))</text>
            
            """
            
            // Add separator line after each row (except the last one)
            if index < relationships.count - 1 {
                let separatorY = rowY + 8
                legend += """
                    <line x1="\(x + padding)" y1="\(separatorY)" x2="\(x + width - padding)" y2="\(separatorY)" class="relationship-separator"/>
                
                """
            }
        }
        
        legend += "</g>\n"
        return legend
    }
    
    private func formatRelationshipForLegend(_ relationship: Relationship) -> String {
        var text = relationship.cardinality.rawValue
        if let comment = relationship.comment {
            text += " (\(comment))"
        }
        return text
    }
    
    // MARK: - Architectural Overview Extraction
    
    private func extractArchitecturalOverview() -> ArchitecturalOverview? {
        guard let content = rawContent else { return nil }
        
        let lines = content.components(separatedBy: .newlines)
        var purpose: String?
        var domain: String?
        var pattern: String?
        var moduleBreakdown: [String] = []
        var keyFeatures: [String] = []
        var dataDistribution: [String] = []
        
        var currentSection: String?
        
        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Skip non-comment lines
            guard trimmed.hasPrefix("#") else { continue }
            
            if trimmed.contains("SCHEMA ARCHITECTURE OVERVIEW") {
                currentSection = "overview"
                continue
            } else if trimmed.contains("MODULE BREAKDOWN") {
                currentSection = "modules"
                continue
            } else if trimmed.contains("KEY ARCHITECTURAL FEATURES") {
                currentSection = "features"
                continue
            } else if trimmed.contains("DATA DISTRIBUTION") {
                currentSection = "distribution"
                continue
            } else if trimmed.contains("RELATIONSHIP DEFINITIONS") {
                break // End of architectural overview
            }
            
            if currentSection == "overview" {
                let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces) // Remove # prefix
                if content.hasPrefix("Database Purpose:") {
                    purpose = String(content.dropFirst("Database Purpose:".count)).trimmingCharacters(in: .whitespaces)
                } else if content.hasPrefix("Domain:") {
                    domain = String(content.dropFirst("Domain:".count)).trimmingCharacters(in: .whitespaces)
                } else if content.hasPrefix("Architecture Pattern:") {
                    pattern = String(content.dropFirst("Architecture Pattern:".count)).trimmingCharacters(in: .whitespaces)
                }
            } else if currentSection == "modules" {
                let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces) // Remove # prefix
                if !content.isEmpty && !content.hasPrefix("=") && content.contains("entities") {
                    moduleBreakdown.append(content)
                }
            } else if currentSection == "features" {
                let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces) // Remove # prefix
                if content.hasPrefix("-") {
                    let feature = String(content.dropFirst(1)).trimmingCharacters(in: .whitespaces)
                    keyFeatures.append(feature)
                }
            } else if currentSection == "distribution" {
                let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces) // Remove # prefix
                if !content.isEmpty && !content.hasPrefix("=") && content.contains("fields") {
                    dataDistribution.append(content)
                }
            }
        }
        
        guard purpose != nil || domain != nil || !moduleBreakdown.isEmpty else {
            return nil
        }
        
        return ArchitecturalOverview(
            purpose: purpose,
            domain: domain,
            architecturePattern: pattern,
            moduleBreakdown: moduleBreakdown,
            keyFeatures: keyFeatures,
            dataDistribution: dataDistribution
        )
    }
    
    private func generateArchitecturalOverview(_ overview: ArchitecturalOverview, layout: SVGLayout) -> String {
        let x = layout.overviewX
        let y = layout.overviewY
        let width = layout.overviewWidth
        let lineHeight = 18
        var currentY = y + 25
        
        var svg = """
        <g class="architectural-overview">
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(layout.overviewHeight - 20)" 
                  fill="url(#overviewGradient)" stroke="#2c3e50" stroke-width="2" rx="8"/>
            <text x="\(x + width/2)" y="\(y + 20)" class="overview-title" text-anchor="middle">Schema Architecture Overview</text>
        
        """
        
        currentY += 20  // Extra spacing below title for better visual hierarchy
        
        if let purpose = overview.purpose {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-label">Purpose:</text>
            <text x="\(x + 85)" y="\(currentY)" class="overview-text">\(xmlEscape(purpose))</text>
            
            """
            currentY += lineHeight
        }
        
        if let domain = overview.domain {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-label">Domain:</text>
            <text x="\(x + 85)" y="\(currentY)" class="overview-text">\(xmlEscape(domain))</text>
            
            """
            currentY += lineHeight
        }
        
        if let pattern = overview.architecturePattern {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-label">Pattern:</text>
            <text x="\(x + 85)" y="\(currentY)" class="overview-text">\(xmlEscape(pattern))</text>
            
            """
            currentY += lineHeight + 8
        } else {
            currentY += 5
        }
        
        // Module Tag Cloud (after pattern section)
        let moduleList = getModuleList()
        if !moduleList.isEmpty {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-label">Modules:</text>
            
            """
            
            var currentX = x + 85 // Start after the label
            let tagSpacing = 8
            let maxRowWidth = x + width - 20 // Leave minimal padding, use almost full width
            
            for moduleInfo in moduleList {
                let moduleId = "module-\(moduleInfo.name.lowercased())"
                let tagText = moduleInfo.name
                let estimatedWidth = tagText.count * 6 + 12 // More accurate estimate: 6px per char + 12px padding
                
                // Check if we need a new line
                if currentX + estimatedWidth > maxRowWidth {
                    currentY += lineHeight
                    currentX = x + 85
                }
                
                svg += """
                <rect x="\(currentX - 4)" y="\(currentY - 12)" width="\(estimatedWidth)" height="16" 
                      fill="#e8f4f8" stroke="#3498db" stroke-width="1" rx="8" opacity="0.7"/>
                <text x="\(currentX)" y="\(currentY)" class="module-tag" 
                      onclick="document.getElementById('\(moduleId)').scrollIntoView({behavior:'smooth'}); var moduleGroup = document.getElementById('\(moduleId)'); if(moduleGroup) { var moduleTitle = moduleGroup.getElementsByClassName('module-title')[0]; var rects = moduleGroup.getElementsByTagName('rect'); if(moduleTitle) { moduleTitle.style.fill='#e74c3c'; moduleTitle.style.fontWeight='900'; } for(var i=0; i&lt;rects.length; i++) { rects[i].style.fill='#e74c3c'; rects[i].style.stroke='#c0392b'; rects[i].style.strokeWidth='2'; } setTimeout(() => { if(moduleTitle) { moduleTitle.style.fill=''; moduleTitle.style.fontWeight=''; } for(var i=0; i&lt;rects.length; i++) { rects[i].style.fill=''; rects[i].style.stroke=''; rects[i].style.strokeWidth=''; } }, 1500); }" 
                      style="cursor: pointer; fill: #2980b9; font-size: 11px;">\(xmlEscape(tagText))</text>
                """
                
                currentX += estimatedWidth + tagSpacing
            }
            currentY += lineHeight + 8
        }
        
        // Data Distribution
        if !overview.dataDistribution.isEmpty {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-section">Data Distribution:</text>
            
            """
            currentY += lineHeight
            
            for distribution in overview.dataDistribution.prefix(3) { // Show max 3 lines
                // Use intelligent text wrapping to preserve all information
                let wrappedLines = wrapText(distribution, maxCharsPerLine: 70)
                
                for (lineIndex, line) in wrappedLines.enumerated() {
                    let prefix = lineIndex == 0 ? "â€¢ " : "  "
                    let textX = x + 25 + (lineIndex == 0 ? 0 : 10)
                    
                    svg += """
                    <text x="\(textX)" y="\(currentY)" class="overview-detail">\(prefix)\(xmlEscape(line))</text>
                    
                    """
                    currentY += lineHeight
                }
            }
            currentY += 5
        }
        
        // Key Architectural Features
        if !overview.keyFeatures.isEmpty {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-section">Key Features:</text>
            
            """
            currentY += lineHeight
            
            for feature in overview.keyFeatures.prefix(3) { // Show max 3 key features
                // Use intelligent text wrapping to preserve all information
                let wrappedLines = wrapText(feature, maxCharsPerLine: 70) // ~70 chars utilizes 400px width better
                
                for (lineIndex, line) in wrappedLines.enumerated() {
                    let prefix = lineIndex == 0 ? "â€¢ " : "  " // Bullet for first line, indent for continuation
                    let textX = x + 25 + (lineIndex == 0 ? 0 : 10) // Extra indent for continuation lines
                    
                    svg += """
                    <text x="\(textX)" y="\(currentY)" class="overview-detail">\(prefix)\(xmlEscape(line))</text>
                    
                    """
                    currentY += lineHeight
                }
            }
            currentY += 5
        }
        
        // Module Breakdown (show first few)
        if !overview.moduleBreakdown.isEmpty {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-section">Key Modules:</text>
            
            """
            currentY += lineHeight
            
            for module in overview.moduleBreakdown.prefix(4) { // Show max 4 modules
                // Use intelligent text wrapping to preserve all information
                let wrappedLines = wrapText(module, maxCharsPerLine: 70)
                
                for (lineIndex, line) in wrappedLines.enumerated() {
                    let prefix = lineIndex == 0 ? "â€¢ " : "  "
                    let textX = x + 25 + (lineIndex == 0 ? 0 : 10)
                    
                    svg += """
                    <text x="\(textX)" y="\(currentY)" class="overview-detail">\(prefix)\(xmlEscape(line))</text>
                    
                    """
                    currentY += lineHeight
                }
            }
        }
        
        svg += "</g>\n"
        return svg
    }
    
    private func getModuleList() -> [(name: String, description: String?)] {
        return document.schemaDefinition.moduleSections.map { moduleSection in
            return (name: moduleSection.name, description: moduleSection.description)
        }
    }
    
    private func generateColorLegend(layout: SVGLayout) -> String {
        let x = layout.colorLegendX
        let y = layout.colorLegendY
        let width = layout.colorLegendWidth
        let height = layout.colorLegendHeight
        let headerHeight = 35  // Increased for better title spacing
        let lineHeight = 20   // Better spacing between rows
        let padding = 15
        
        var legend = """
        <g class="color-legend">
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(height)" 
                  fill="url(#overviewGradient)" stroke="#2c3e50" stroke-width="2" rx="8"/>
            <text x="\(x + width/2)" y="\(y + 20)" class="overview-title" text-anchor="middle">Color Legend</text>
        
        """
        
        // Field-level colors (text colors)
        let fieldColors = [
            ("Required Fields", "*", "#ffa502"),
            ("Optional Fields", "â€”", "#8e8e93"),
            ("Indexed Fields", "!", "#5352ed"),
            ("Sensitive Fields", "@", "#ff4757"),
            ("Primary Key Fields", "pk", "#007aff"),
            ("Foreign Key Fields", "fk", "#5856d6")
        ]
        
        // Attribute colors (tag colors)  
        let attributeColors = [
            ("Default Values", "def", "#e67e22"),
            ("App/JSON Fields", "app", "#27ae60"), 
            ("DB Constraints", "pk", "#3498db"),
            ("Encrypted Fields", "enc", "#ff4757"),
            ("System Values", "sys", "#34495e")
        ]
        
        var currentY = y + headerHeight + 5
        
        // Field Colors Section
        legend += """
        <text x="\(x + padding)" y="\(currentY + 10)" class="legend-header-text" font-size="12px" font-weight="700">Field Level Colors</text>
        
        """
        currentY += 25
        
        for (index, (label, symbol, color)) in fieldColors.enumerated() {
            let row = index / 2  // 2 columns
            let col = index % 2
            let itemX = x + padding + (col * (width - 2 * padding) / 2)
            let itemY = currentY + (row * lineHeight)
            
            legend += """
            <circle cx="\(itemX + 8)" cy="\(itemY - 3)" r="5" fill="\(color)" stroke="none"/>
            <text x="\(itemX + 18)" y="\(itemY - 3)" class="overview-detail" font-size="10px" dominant-baseline="middle">\(xmlEscape(symbol)) - \(xmlEscape(label))</text>
            
            """
        }
        
        currentY += (fieldColors.count + 1) / 2 * lineHeight + 15
        
        // Attribute Colors Section
        legend += """
        <text x="\(x + padding)" y="\(currentY + 10)" class="legend-header-text" font-size="12px" font-weight="700">Field Attribute Colors</text>
        
        """
        currentY += 25
        
        for (index, (label, symbol, color)) in attributeColors.enumerated() {
            let row = index / 2  // 2 columns
            let col = index % 2
            let itemX = x + padding + (col * (width - 2 * padding) / 2)
            let itemY = currentY + (row * lineHeight)
            
            legend += """
            <rect x="\(itemX + 3)" y="\(itemY - 8)" width="20" height="10" fill="\(color)" stroke="rgba(52, 73, 94, 0.8)" stroke-width="0.8" rx="4"/>
            <text x="\(itemX + 27)" y="\(itemY - 3)" class="overview-detail" font-size="10px" dominant-baseline="middle">\(xmlEscape(symbol)) - \(xmlEscape(label))</text>
            
            """
        }
        
        legend += "</g>\n"
        return legend
    }
    
    private func generateBrowserMessage(layout: SVGLayout) -> String {
        let messageText = "ðŸ’¡ Open in Web Browser for full interactivity (tooltips, navigation, hover effects)"
        let x = layout.totalWidth / 2
        let y = 20
        let messageWidth = 600
        let messageHeight = 25
        let messageX = x - (messageWidth / 2)
        let messageY = y - 12
        
        let browserMessage = """
        <g class="browser-message" id="browser-message">
            <rect x="\(messageX)" y="\(messageY)" width="\(messageWidth)" height="\(messageHeight)" 
                  fill="rgba(52, 152, 219, 0.1)" stroke="rgba(52, 152, 219, 0.3)" stroke-width="1" 
                  rx="12" opacity="0.9"/>
            <text x="\(x)" y="\(y)" text-anchor="middle" 
                  font-family="'Segoe UI', Arial, sans-serif" font-size="12px" font-weight="500" 
                  fill="#2980b9" fill-opacity="0.8">
                \(xmlEscape(messageText))
            </text>
        </g>
        <script type="text/javascript">
        <![CDATA[
        // Hide browser message when JavaScript is available (browser context)
        (function() {
            var msg = document.getElementById('browser-message');
            if (msg) { msg.style.display = 'none'; }
        })();
        ]]>
        </script>
        
        """
        
        return browserMessage
    }
    
    private func generateAttribution(layout: SVGLayout) -> String {
        let x = layout.attributionX
        let y = layout.attributionY
        let width = layout.attributionWidth
        let height = layout.attributionHeight
        
        let borderPadding = 3
        let innerX = x + borderPadding
        let innerY = y + borderPadding
        let innerWidth = width - (2 * borderPadding)
        let innerHeight = height - (2 * borderPadding)
        
        let attribution = """
        <g class="attribution">
            <!-- Animated gradient border -->
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(height)" 
                  fill="url(#attributionBorderGradient)" 
                  rx="16" 
                  filter="url(#attributionShadow)"/>
            
            <!-- Inner transparent background -->
            <rect x="\(innerX)" y="\(innerY)" width="\(innerWidth)" height="\(innerHeight)" 
                  fill="url(#attributionGradient)" 
                  rx="13"/>
            
            <!-- Main text with elegant styling -->
            <text x="\(x + width/2)" y="\(y + height/2 - 3)" 
                  text-anchor="middle" 
                  font-family="'Segoe UI', Arial, sans-serif" 
                  font-size="14px" 
                  font-weight="700" 
                  fill="#2c3e50" 
                  fill-opacity="0.9">
                \(xmlEscape(Self.attributionTitle))
            </text>
            
            <!-- Subtle version text -->
            <text x="\(x + width/2)" y="\(y + height/2 + 12)" 
                  text-anchor="middle" 
                  font-family="'Segoe UI', Arial, sans-serif" 
                  font-size="10px" 
                  font-weight="500" 
                  fill="#495057" 
                  fill-opacity="0.8">
                \(xmlEscape(Self.attributionSubtitle))
            </text>
        </g>
        
        """
        
        return attribution
    }
    
    // MARK: - Text Wrapping
    
    private func wrapText(_ text: String, maxCharsPerLine: Int) -> [String] {
        if text.count <= maxCharsPerLine {
            return [text]
        }
        
        var lines: [String] = []
        var currentLine = ""
        let words = text.split(separator: " ", omittingEmptySubsequences: false)
        
        for word in words {
            let testLine = currentLine.isEmpty ? String(word) : currentLine + " " + String(word)
            
            if testLine.count <= maxCharsPerLine {
                currentLine = testLine
            } else {
                // Current line is full, start a new line
                if !currentLine.isEmpty {
                    lines.append(currentLine)
                }
                currentLine = String(word)
                
                // If a single word is longer than max chars, we need to break it
                if currentLine.count > maxCharsPerLine {
                    let brokenWord = currentLine
                    currentLine = ""
                    // Break long word into chunks
                    var startIndex = brokenWord.startIndex
                    while startIndex < brokenWord.endIndex {
                        let endIndex = brokenWord.index(startIndex, offsetBy: min(maxCharsPerLine, brokenWord.distance(from: startIndex, to: brokenWord.endIndex)))
                        lines.append(String(brokenWord[startIndex..<endIndex]))
                        startIndex = endIndex
                    }
                }
            }
        }
        
        if !currentLine.isEmpty {
            lines.append(currentLine)
        }
        
        return lines
    }
    
    // MARK: - XML Escaping
    
    private func xmlEscape(_ text: String) -> String {
        return text
            .replacingOccurrences(of: "&", with: "&amp;")
            .replacingOccurrences(of: "<", with: "&lt;")
            .replacingOccurrences(of: ">", with: "&gt;")
            .replacingOccurrences(of: "\"", with: "&quot;")
            .replacingOccurrences(of: "'", with: "&apos;")
    }
}

// MARK: - Layout Data Structures

struct SVGLayout {
    var entityPositions: [String: EntityPosition] = [:]
    var moduleHeaders: [(x: Int, y: Int, width: Int, name: String, description: String?)] = []
    var swimlanes: [(x: Int, y: Int, width: Int, height: Int)] = []
    var versionX: Int = 0
    var versionY: Int = 0
    var versionWidth: Int = 0
    var versionHeight: Int = 0
    var legendX: Int = 0
    var legendY: Int = 0
    var legendWidth: Int = 0
    var legendHeight: Int = 0
    var overviewHeight: Int = 0
    var overviewX: Int = 0
    var overviewY: Int = 0
    var overviewWidth: Int = 0
    var colorLegendX: Int = 0
    var colorLegendY: Int = 0
    var colorLegendWidth: Int = 0
    var colorLegendHeight: Int = 0
    var attributionX: Int = 0
    var attributionY: Int = 0
    var attributionWidth: Int = 0
    var attributionHeight: Int = 0
    var entitiesStartY: Int = 0
    var totalWidth: Int = 0
    var totalHeight: Int = 0
}

struct EntityPosition {
    let x: Int
    let y: Int
    let width: Int
    let height: Int
}

struct ArchitecturalOverview {
    let purpose: String?
    let domain: String?
    let architecturePattern: String?
    let moduleBreakdown: [String]
    let keyFeatures: [String]
    let dataDistribution: [String]
} 