import Foundation

public class DBSoupSVGGenerator {
    private let document: DBSoupDocument
    private let backgroundColor: String?
    private let rawContent: String?
    
    public init(document: DBSoupDocument, backgroundColor: String? = "#ecf0f1", rawContent: String? = nil) {
        self.document = document
        self.backgroundColor = backgroundColor
        self.rawContent = rawContent
    }
    
    // MARK: - Background Color Presets
    
    /// Recommended background colors for professional appearance
    public static let backgroundColors = BackgroundColors()
    
    public struct BackgroundColors {
        public let transparent: String? = nil
        public let lightGrey = "#f5f5f5"
        public let mediumGrey = "#e8e8e8"
        public let blueGrey = "#ecf0f1"      // Default background color
        public let warmGrey = "#f8f9fa"
        public let documentWhite = "#ffffff"
    }
    
    // MARK: - Attribution Constants
    
    /// Attribution text displayed in the generated SVG
    private static let attributionTitle = "Generated by DBSoup"
    private static let attributionSubtitle = "Database Schema Visualization"
    
    // MARK: - Convenience Initializers
    
    /// Creates SVG generator with transparent background (no background color)
    public static func withTransparentBackground(document: DBSoupDocument) -> DBSoupSVGGenerator {
        return DBSoupSVGGenerator(document: document, backgroundColor: backgroundColors.transparent)
    }
    
    /// Creates SVG generator with light grey background (recommended for maximum contrast)
    public static func withLightGreyBackground(document: DBSoupDocument) -> DBSoupSVGGenerator {
        return DBSoupSVGGenerator(document: document, backgroundColor: backgroundColors.lightGrey)
    }
    
    /// Creates SVG generator with blue-grey background (default, professional look)
    public static func withBlueGreyBackground(document: DBSoupDocument) -> DBSoupSVGGenerator {
        return DBSoupSVGGenerator(document: document, backgroundColor: backgroundColors.blueGrey)
    }
    
    /// Creates SVG generator with warm grey background (recommended for documentation)
    public static func withWarmGreyBackground(document: DBSoupDocument) -> DBSoupSVGGenerator {
        return DBSoupSVGGenerator(document: document, backgroundColor: backgroundColors.warmGrey)
    }
    
    public func generateSVG() -> String {
        let _ = getAllEntities() // Keep for backward compatibility
        let entitiesByModule = getEntitiesByModule()
        let allRelationships = getAllRelationships()
        let architecturalOverview = extractArchitecturalOverview()
        
        // Calculate layout with dynamic sizing, legend space, and architectural overview
        let layout = calculateModularLayout(entitiesByModule: entitiesByModule, relationships: allRelationships, architecturalOverview: architecturalOverview)
        
        var svg = """
        <svg xmlns="http://www.w3.org/2000/svg" 
             width="\(layout.totalWidth)" 
             height="\(layout.totalHeight)" 
             viewBox="0 0 \(layout.totalWidth) \(layout.totalHeight)"
             preserveAspectRatio="xMidYMid meet">
        <defs>
            <linearGradient id="headerGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#4a90e2;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#357abd;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="entityGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#1a1a1a;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#2d2d2d;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="embeddedHeaderGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#ffeb3b;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#f1c40f;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="embeddedEntityGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#2d2410;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#3d3015;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="legendGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#2c3e50;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#34495e;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="legendHeaderGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#e74c3c;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#c0392b;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="overviewGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#f8f9fa;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#e9ecef;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="moduleHeaderGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#3498db;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#2980b9;stop-opacity:1" />
            </linearGradient>
            <linearGradient id="attributionGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#667eea;stop-opacity:0.6" />
                <stop offset="100%" style="stop-color:#764ba2;stop-opacity:0.6" />
            </linearGradient>
            <filter id="attributionShadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="2" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.15"/>
            </filter>
        </defs>
        <style>
        svg { max-width: none !important; height: auto !important; }
        .entity-box { fill: url(#entityGradient); stroke: #444444; stroke-width: 2; }
        .entity-header { fill: url(#headerGradient); stroke: #444444; stroke-width: 2; }
        .entity-title { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; fill: white; }
        .embedded-entity-box { fill: url(#embeddedEntityGradient); stroke: #f1c40f; stroke-width: 2; stroke-dasharray: 8,4; }
        .embedded-entity-header { fill: url(#embeddedHeaderGradient); stroke: #f1c40f; stroke-width: 2; stroke-dasharray: 8,4; }
        .embedded-entity-title { font-family: Arial, sans-serif; font-size: 15px; font-weight: bold; fill: #2c3e50; font-style: italic; }
        .field-text { font-family: 'Courier New', monospace; font-size: 12px; }
        .embedded-field-text { font-family: 'Courier New', monospace; font-size: 11px; font-style: italic; }
        .entity-comment { fill: white; font-style: italic; font-size: 11px; font-weight: normal; }
        .embedded-entity-comment { fill: #2c3e50; font-style: italic; font-size: 11px; font-weight: normal; }
        .required { fill: #ffa502; }
        .optional { fill: #c7c7c7; }
        .indexed { fill: #5352ed; }
        .sensitive { fill: #ff4757; }
        .foreign-key { fill: #e056fd; cursor: pointer; }
        .embedded-entity-field { fill: #ffeb3b; cursor: pointer; }
        .embedded-required { fill: #ffa502; }
        .embedded-optional { fill: #c7c7c7; }
        .embedded-indexed { fill: #5352ed; }
        .embedded-sensitive { fill: #ff4757; }
        .embedded-foreign-key { fill: #e056fd; cursor: pointer; }
        .embedded-embedded-entity-field { fill: #ffeb3b; cursor: pointer; }
        
        /* Smooth transitions for interactive fields */
        .foreign-key, .embedded-foreign-key, .embedded-entity-field, .embedded-embedded-entity-field {
            transition: fill 0.2s ease-in-out, filter 0.2s ease-in-out;
        }
        
        /* Immediate hover feedback for interactive fields */
        .foreign-key:hover { 
            fill: #ff69b4; 
            filter: drop-shadow(0 0 6px rgba(224, 86, 253, 0.8)) brightness(1.2);
        }
        .embedded-foreign-key:hover { 
            fill: #ff69b4; 
            filter: drop-shadow(0 0 6px rgba(224, 86, 253, 0.8)) brightness(1.2);
        }
        .embedded-entity-field:hover { 
            fill: #ffff00; 
            filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.8)) brightness(1.2);
        }
        .embedded-embedded-entity-field:hover { 
            fill: #ffff00; 
            filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.8)) brightness(1.2);
        }
        
        /* Enhanced anchor styling for better UX */
        a {
            cursor: pointer !important;
            position: relative;
        }
        
        /* Instant custom tooltips for SVG */
        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
            font-weight: 500;
            fill: white;
            pointer-events: none;
            transition: opacity 0.1s ease-in;
        }
        
        .tooltip-bg {
            visibility: hidden;
            opacity: 0;
            fill: rgba(44, 62, 80, 0.95);
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 1;
            rx: 6;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.4));
            pointer-events: none;
            transition: opacity 0.1s ease-in;
        }
        
        .tooltip-group:hover .tooltip-bg,
        .tooltip-group:hover .tooltip-text,
        a:hover + .tooltip-group .tooltip-bg,
        a:hover + .tooltip-group .tooltip-text,
        .interactive-field:hover + .tooltip-group .tooltip-bg,
        .interactive-field:hover + .tooltip-group .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .legend-box { fill: url(#legendGradient); stroke: #34495e; stroke-width: 2; opacity: 1; }
        .legend-header { fill: url(#legendHeaderGradient); stroke: #c0392b; stroke-width: 2; }
        .legend-title { font-family: Arial, sans-serif; font-size: 14px; font-weight: bold; fill: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        .legend-text { font-family: 'Courier New', monospace; font-size: 11px; fill: #ecf0f1; font-weight: bold; text-shadow: 1px 1px 3px rgba(0,0,0,0.9); }
        .legend-row { fill: none; stroke: #7f8c8d; stroke-width: 1; opacity: 0.8; stroke-dasharray: 2,2; }
        .overview-title { font-family: Arial, sans-serif; font-size: 18px; font-weight: bold; fill: #2c3e50; }
        .module-title { font-family: Arial, sans-serif; font-size: 16px; font-weight: 600; fill: #2c3e50; }
        .module-description { font-family: Arial, sans-serif; font-size: 12px; font-weight: normal; fill: #7f8c8d; }
        .module-link { font-family: Arial, sans-serif; font-size: 12px; font-weight: normal; fill: #3498db; }
        .module-link:hover { fill: #2980b9; }
        .module-tag { font-family: Arial, sans-serif; font-size: 11px; font-weight: 500; fill: #2980b9; }
        .module-tag:hover { fill: #1a5999; }
        .overview-label { font-family: Arial, sans-serif; font-size: 12px; font-weight: bold; fill: #2c3e50; }
        .overview-text { font-family: Arial, sans-serif; font-size: 12px; fill: #34495e; }
        .overview-section { font-family: Arial, sans-serif; font-size: 12px; font-weight: bold; fill: #2980b9; }
        .overview-detail { font-family: Arial, sans-serif; font-size: 11px; fill: #34495e; }
        </style>
        
        """
        
        // Add background if specified
        if let bgColor = backgroundColor {
            svg += """
            <rect x="0" y="0" width="\(layout.totalWidth)" height="\(layout.totalHeight)" fill="\(bgColor)" opacity="1"/>
            
            """
        }
        
        // Generate architectural overview if available
        if let overview = architecturalOverview {
            svg += generateArchitecturalOverview(overview, layout: layout)
        }
        
        // Generate module headers and swimlanes
        svg += generateModuleHeaders(layout: layout)
        svg += generateSwimlanes(layout: layout)
        
        // Generate entities organized by module
        for moduleInfo in entitiesByModule {
            // Generate standard entities first
            for entity in moduleInfo.standardEntities {
                svg += generateEntityBox(entity: entity, layout: layout)
            }
            // Then embedded entities
            for entity in moduleInfo.embeddedEntities {
                svg += generateEntityBox(entity: entity, layout: layout)
            }
        }
        
        // Generate relationships legend
        if !allRelationships.isEmpty {
            svg += generateRelationshipsLegend(relationships: allRelationships, layout: layout)
        }
        
        // Generate color legend
        svg += generateColorLegend(layout: layout)
        
        // Generate attribution
        svg += generateAttribution(layout: layout)
        
        svg += "</svg>"
        return svg
    }
    
    private func getAllEntities() -> [Entity] {
        var entities: [Entity] = []
        for moduleSection in document.schemaDefinition.moduleSections {
            entities.append(contentsOf: moduleSection.entities)
        }
        // Sort entities alphabetically by name for better scanning
        return entities.sorted { $0.name < $1.name }
    }
    
    private func getEntitiesByModule() -> [(moduleName: String, moduleDescription: String?, standardEntities: [Entity], embeddedEntities: [Entity])] {
        return document.schemaDefinition.moduleSections.map { moduleSection in
            let standardEntities = moduleSection.entities.filter { $0.type == .standard }.sorted { $0.name < $1.name }
            let embeddedEntities = moduleSection.entities.filter { $0.type == .embedded }.sorted { $0.name < $1.name }
            return (moduleName: moduleSection.name, moduleDescription: moduleSection.description, standardEntities: standardEntities, embeddedEntities: embeddedEntities)
        }
    }

    
    private func getAllRelationships() -> [Relationship] {
        return document.relationshipDefinitions?.relationships ?? []
    }
    
    private func generateEntityBox(entity: Entity, layout: SVGLayout) -> String {
        guard let position = layout.entityPositions[entity.name] else {
            return ""
        }
        
        let headerHeight = 35
        let fieldHeight = 18
        let padding = 12
        
        // Determine styles based on entity type
        let isEmbedded = entity.type == .embedded
        let entityBoxClass = isEmbedded ? "embedded-entity-box" : "entity-box"
        let entityHeaderClass = isEmbedded ? "embedded-entity-header" : "entity-header"
        let entityTitleClass = isEmbedded ? "embedded-entity-title" : "entity-title"
        let fieldTextClass = isEmbedded ? "embedded-field-text" : "field-text"
        let commentClass = isEmbedded ? "embedded-entity-comment" : "entity-comment"
        
        var svg = """
        <g id="\(entity.name)">
        <!-- Entity container -->
        <rect x="\(position.x)" y="\(position.y)" width="\(position.width)" height="\(position.height)" class="\(entityBoxClass)" rx="8"/>
        
        <!-- Entity header -->
        <rect x="\(position.x)" y="\(position.y)" width="\(position.width)" height="\(headerHeight)" class="\(entityHeaderClass)" rx="8"/>
        
        <!-- Entity comment above title -->
        """
        
        if let comment = entity.comment {
            svg += """
            <text x="\(position.x + position.width/2)" y="\(position.y + 12)" class="\(commentClass)" text-anchor="middle">\(xmlEscape(comment))</text>
            
            """
        }
        
        svg += """
        <!-- Entity title -->
        <text x="\(position.x + position.width/2)" y="\(position.y + (entity.comment != nil ? 27 : 22))" class="\(entityTitleClass)" text-anchor="middle">\(xmlEscape(entity.name))</text>
        
        """
        
        // Generate ALL fields (no truncation)
        let startY = position.y + headerHeight + 15
        for (index, field) in entity.fields.enumerated() {
            let fieldY = startY + (index * fieldHeight)
            let fieldText = formatFieldText(field: field)
            let fieldClass = getFieldClass(field: field, isEmbedded: isEmbedded)
            
            // Check if this is a foreign key field for navigation
            if let referencedEntity = getForeignKeyReference(field: field) {
                let tooltipText = referencedEntity
                let tooltipPadding = 8
                let tooltipHeight = 20
                let tooltipWidth = max(tooltipText.count * 8 + (tooltipPadding * 2), 60)  // Better width calculation
                
                // Center tooltip horizontally relative to the field
                let fieldTextWidth = fieldText.count * 7  // Approximate field text width
                let fieldCenterX = position.x + padding + (fieldTextWidth / 2)
                var tooltipX = fieldCenterX - (tooltipWidth / 2)
                
                // Ensure tooltip doesn't go outside entity boundaries
                let minX = position.x + 5
                let maxX = position.x + position.width - tooltipWidth - 5
                tooltipX = max(minX, min(tooltipX, maxX))
                
                let tooltipY = fieldY - tooltipHeight - 8  // More space above the field
                
                // Text positioning - centered within rectangle
                let textCenterX = tooltipX + (tooltipWidth / 2)
                let textCenterY = tooltipY + (tooltipHeight / 2) + 4  // Adjust for SVG text baseline
                
                svg += """
                <text x="\(position.x + padding)" y="\(fieldY)" 
                      class="\(fieldTextClass) \(fieldClass) interactive-field"
                      onclick="document.getElementById('\(referencedEntity)').scrollIntoView({behavior:'smooth'}); document.getElementById('\(referencedEntity)').style.outline='3px solid #9b59b6'; setTimeout(() => document.getElementById('\(referencedEntity)').style.outline='none', 1000);" 
                      style="cursor: pointer;">\(xmlEscape(fieldText))</text>
                <g class="tooltip-group">
                    <rect x="\(tooltipX)" y="\(tooltipY)" width="\(tooltipWidth)" height="\(tooltipHeight)" class="tooltip-bg"/>
                    <text x="\(textCenterX)" y="\(textCenterY)" text-anchor="middle" class="tooltip-text">\(xmlEscape(tooltipText))</text>
                </g>
                
                """
            } else if let embeddedEntity = getEmbeddedEntityReference(field: field) {
                let tooltipText = embeddedEntity
                let tooltipPadding = 8
                let tooltipHeight = 20
                let tooltipWidth = max(tooltipText.count * 8 + (tooltipPadding * 2), 60)  // Better width calculation
                
                // Center tooltip horizontally relative to the field
                let fieldTextWidth = fieldText.count * 7  // Approximate field text width
                let fieldCenterX = position.x + padding + (fieldTextWidth / 2)
                var tooltipX = fieldCenterX - (tooltipWidth / 2)
                
                // Ensure tooltip doesn't go outside entity boundaries
                let minX = position.x + 5
                let maxX = position.x + position.width - tooltipWidth - 5
                tooltipX = max(minX, min(tooltipX, maxX))
                
                let tooltipY = fieldY - tooltipHeight - 8  // More space above the field
                
                // Text positioning - centered within rectangle
                let textCenterX = tooltipX + (tooltipWidth / 2)
                let textCenterY = tooltipY + (tooltipHeight / 2) + 4  // Adjust for SVG text baseline
                
                svg += """
                <text x="\(position.x + padding)" y="\(fieldY)" 
                      class="\(fieldTextClass) \(fieldClass) interactive-field"
                      onclick="document.getElementById('\(embeddedEntity)').scrollIntoView({behavior:'smooth'}); document.getElementById('\(embeddedEntity)').style.outline='3px solid #8e44ad'; setTimeout(() => document.getElementById('\(embeddedEntity)').style.outline='none', 1000);" 
                      style="cursor: pointer;">\(xmlEscape(fieldText))</text>
                <g class="tooltip-group">
                    <rect x="\(tooltipX)" y="\(tooltipY)" width="\(tooltipWidth)" height="\(tooltipHeight)" class="tooltip-bg"/>
                    <text x="\(textCenterX)" y="\(textCenterY)" text-anchor="middle" class="tooltip-text">\(xmlEscape(tooltipText))</text>
                </g>
                
                """
            } else {
                svg += """
                <text x="\(position.x + padding)" y="\(fieldY)" class="\(fieldTextClass) \(fieldClass)">\(xmlEscape(fieldText))</text>
                
                """
            }
        }
        
        svg += "</g>\n"
        return svg
    }
    
    private func getFieldClass(field: Field, isEmbedded: Bool = false) -> String {
        let prefix = isEmbedded ? "embedded-" : ""
        
        // Check for embedded entity field first (highest priority for color)
        if case .embeddedEntity(_) = field.dataType {
            return "\(prefix)embedded-entity-field"
        } else if case .relationshipArray(_, _) = field.dataType {
            return "\(prefix)embedded-entity-field"
        } else if isEmbeddedEntityReference(field: field) {
            return "\(prefix)embedded-entity-field"
        } else if field.constraints.contains(where: { $0.name.hasPrefix("FK") }) {
            return "\(prefix)foreign-key"
        } else if field.prefixes.contains(.sensitive) {
            return "\(prefix)sensitive"
        } else if field.prefixes.contains(.required) {
            return "\(prefix)required"
        } else if field.prefixes.contains(.indexed) {
            return "\(prefix)indexed"
        } else {
            return "\(prefix)optional"
        }
    }
    
    private func isEmbeddedEntityReference(field: Field) -> Bool {
        let allEntities = getAllEntities()
        let embeddedEntityNames = allEntities.filter { $0.type == .embedded }.map { $0.name }
        
        // Check if field data type references an embedded entity
        switch field.dataType {
        case .simple(let typeName):
            return embeddedEntityNames.contains(typeName)
        case .relationshipArray(let typeName, _):
            return embeddedEntityNames.contains(typeName)
        case .array(let innerType):
            if case .simple(let innerTypeName) = innerType {
                return embeddedEntityNames.contains(innerTypeName)
            }
            return false
        default:
            return false
        }
    }
    
    private func getForeignKeyReference(field: Field) -> String? {
        // Check if field has a foreign key constraint
        for constraint in field.constraints {
            if constraint.name == "FK" {
                // Extract referenced entity name from constraint value
                // Format: EntityName.fieldName
                if let value = constraint.value,
                   let dotIndex = value.firstIndex(of: ".") {
                    let entityName = String(value[..<dotIndex])
                    return entityName
                }
            }
        }
        return nil
    }
    
    private func getEmbeddedEntityReference(field: Field) -> String? {
        let allEntities = getAllEntities()
        let embeddedEntityNames = allEntities.filter { $0.type == .embedded }.map { $0.name }
        
        // Check if field data type references an embedded entity
        switch field.dataType {
        case .simple(let typeName):
            return embeddedEntityNames.contains(typeName) ? typeName : nil
        case .embeddedEntity(let typeName):
            return typeName
        case .relationshipArray(let typeName, _):
            return embeddedEntityNames.contains(typeName) ? typeName : nil
        case .array(let innerType):
            if case .simple(let innerTypeName) = innerType {
                return embeddedEntityNames.contains(innerTypeName) ? innerTypeName : nil
            } else if case .embeddedEntity(let innerTypeName) = innerType {
                return innerTypeName
            }
            return nil
        default:
            return nil
        }
    }
    
    private func formatFieldText(field: Field) -> String {
        let prefixText = field.prefixes.map { $0.rawValue }.joined()
        let nameText = field.names.joined(separator: ", ")
        let typeText = formatDataType(field.dataType)
        let constraintText = field.constraints.map { $0.name }.joined(separator: ", ")
        
        var result = "\(prefixText)\(nameText): \(typeText)"
        if !constraintText.isEmpty {
            result += " [\(constraintText)]"
        }
        return result
    }
    
    private func formatDataType(_ dataType: DataType) -> String {
        switch dataType {
        case .simple(let type):
            return type
        case .parametric(let type, let params):
            return "\(type)(\(params.joined(separator: ", ")))"
        case .array(let innerType):
            return "[\(formatDataType(innerType))]"
        case .jsonObject:
            return "JSON"
        case .relationshipArray(let type, _):
            return "[\(type)]"
        case .embeddedEntity(let type):
            return type
        }
    }
    
    private func generateModuleHeaders(layout: SVGLayout) -> String {
        var svg = ""
        
        for header in layout.moduleHeaders {
            let hasDescription = header.description != nil && !header.description!.isEmpty
            let barHeight = hasDescription ? 40 : 32
            let moduleId = "module-\(header.name.lowercased())"
            
            svg += """
            <g class="module-header" id="\(moduleId)">
                <rect x="\(header.x)" y="\(header.y)" width="4" height="\(barHeight)" 
                      fill="#3498db" rx="2"/>
                <text x="\(header.x + 20)" y="\(header.y + 21)" 
                      class="module-title">\(xmlEscape(header.name))</text>
            """
            
            if let description = header.description, !description.isEmpty {
                svg += """
                <text x="\(header.x + 20)" y="\(header.y + 36)" 
                      class="module-description">\(xmlEscape(description))</text>
                """
            }
            
            svg += """
            </g>
            
            """
        }
        
        return svg
    }
    
    private func generateSwimlanes(layout: SVGLayout) -> String {
        var svg = ""
        
        for swimlane in layout.swimlanes {
            svg += """
            <line x1="\(swimlane.x)" y1="\(swimlane.y)" x2="\(swimlane.x + swimlane.width)" y2="\(swimlane.y)" 
                  stroke="#bdc3c7" stroke-width="2" stroke-dasharray="10,5" opacity="0.6"/>
            
            """
        }
        
        return svg
    }
    
    // MARK: - Layout Calculation
    
    private func calculateModularLayout(entitiesByModule: [(moduleName: String, moduleDescription: String?, standardEntities: [Entity], embeddedEntities: [Entity])], relationships: [Relationship], architecturalOverview: ArchitecturalOverview?) -> SVGLayout {
        var layout = SVGLayout()
        let basePadding = 40
        let entityPadding = 60
        let legendPadding = 30
        let maxEntitiesPerRow = 3
        let moduleHeaderHeight = 50  // Increased to accommodate descriptions
        let swimlaneSpacing = 30
        
        // Calculate architectural overview height (but don't use it for entity positioning)
        var overviewHeight = 0
        if let overview = architecturalOverview {
            overviewHeight = calculateOverviewHeight(overview: overview)
            layout.overviewHeight = overviewHeight
        }
        
        var entityPositions: [String: EntityPosition] = [:]
        var moduleHeaders: [(x: Int, y: Int, width: Int, name: String, description: String?)] = []
        var swimlanes: [(x: Int, y: Int, width: Int, height: Int)] = []
        
        let currentX = basePadding
        var currentY = basePadding
        layout.entitiesStartY = currentY
        var maxModuleWidth = 0
        
        for (index, moduleInfo) in entitiesByModule.enumerated() {
            let moduleStartY = currentY
            
            // Add module header
            currentY += moduleHeaderHeight
            
            // Process standard entities first
            var moduleMaxX = currentX
            let (standardPositions, standardEndY, standardMaxX) = layoutEntitiesInModule(
                entities: moduleInfo.standardEntities,
                startX: currentX,
                startY: currentY,
                maxEntitiesPerRow: maxEntitiesPerRow,
                entityPadding: entityPadding
            )
            entityPositions.merge(standardPositions) { _, new in new }
            currentY = standardEndY
            moduleMaxX = max(moduleMaxX, standardMaxX)
            
            // Add small gap between standard and embedded entities if both exist
            if !moduleInfo.standardEntities.isEmpty && !moduleInfo.embeddedEntities.isEmpty {
                currentY += entityPadding / 2
            }
            
            // Process embedded entities
            let (embeddedPositions, embeddedEndY, embeddedMaxX) = layoutEntitiesInModule(
                entities: moduleInfo.embeddedEntities,
                startX: currentX,
                startY: currentY,
                maxEntitiesPerRow: maxEntitiesPerRow,
                entityPadding: entityPadding
            )
            entityPositions.merge(embeddedPositions) { _, new in new }
            currentY = embeddedEndY
            moduleMaxX = max(moduleMaxX, embeddedMaxX)
            
            // Store module header info
            let moduleWidth = moduleMaxX - currentX + basePadding
            moduleHeaders.append((x: currentX, y: moduleStartY, width: moduleWidth, name: moduleInfo.moduleName, description: moduleInfo.moduleDescription))
            maxModuleWidth = max(maxModuleWidth, moduleWidth)
            
            // Add swimlane (except for last module)
            if index < entitiesByModule.count - 1 {
                currentY += swimlaneSpacing
                swimlanes.append((x: basePadding, y: currentY - swimlaneSpacing/2, width: moduleMaxX - basePadding + basePadding, height: 1))
            }
        }
        
        // Store layout information
        layout.entityPositions = entityPositions
        layout.moduleHeaders = moduleHeaders
        layout.swimlanes = swimlanes
        
        // Calculate entities area dimensions
        let maxX = max(entityPositions.values.map { $0.x + $0.width }.max() ?? 0, maxModuleWidth)
        let entitiesBottomY = currentY
        
        // Calculate legend dimensions and position
        let legendWidth = 400
        let legendHeight = calculateLegendHeight(relationships: relationships)
        let legendX = maxX + legendPadding
        let legendY = basePadding
        
        // Calculate overview position (below legend, same width)
        let overviewX = legendX
        let overviewY = legendY + legendHeight + 20  // 20px gap below legend
        let overviewWidth = legendWidth  // Same width as legend
        
        // Calculate color legend position (below overview, same width)
        let colorLegendHeight = 100  // Better fit for content
        let colorLegendX = overviewX
        let colorLegendY = overviewY + (overviewHeight - 20) + 20  // 20px gap below overview (accounting for overview height adjustment)
        let colorLegendWidth = overviewWidth  // Same width as overview
        
        // Calculate attribution position (below color legend, same width)
        let attributionHeight = 50  // Fixed height for attribution
        let attributionX = colorLegendX
        let attributionY = colorLegendY + colorLegendHeight + 20  // 20px gap below color legend (consistent with other gaps)
        let attributionWidth = colorLegendWidth  // Same width as color legend
        
        // Set layout properties
        layout.entityPositions = entityPositions
        layout.legendX = legendX
        layout.legendY = legendY
        layout.legendWidth = legendWidth
        layout.legendHeight = legendHeight
        layout.overviewX = overviewX
        layout.overviewY = overviewY
        layout.overviewWidth = overviewWidth
        layout.colorLegendX = colorLegendX
        layout.colorLegendY = colorLegendY
        layout.colorLegendWidth = colorLegendWidth
        layout.colorLegendHeight = colorLegendHeight
        layout.attributionX = attributionX
        layout.attributionY = attributionY
        layout.attributionWidth = attributionWidth
        layout.attributionHeight = attributionHeight
        layout.totalWidth = max(maxX + basePadding, legendX + legendWidth + basePadding)
        layout.totalHeight = max(entitiesBottomY + basePadding, 
                                max(legendY + legendHeight + basePadding, 
                                    max(overviewY + overviewHeight + basePadding,
                                        max(colorLegendY + colorLegendHeight + basePadding,
                                            attributionY + attributionHeight + basePadding))))
        
        return layout
    }
    
    private func layoutEntitiesInModule(entities: [Entity], startX: Int, startY: Int, maxEntitiesPerRow: Int, entityPadding: Int) -> ([String: EntityPosition], Int, Int) {
        var entityPositions: [String: EntityPosition] = [:]
        var currentX = startX
        var currentY = startY
        var currentRowHeight = 0
        var entitiesInCurrentRow = 0
        var maxX = startX
        
        for entity in entities {
            let dimensions = calculateEntityDimensions(entity: entity)
            
            // Check if we need a new row
            if entitiesInCurrentRow >= maxEntitiesPerRow {
                currentX = startX
                currentY += currentRowHeight + entityPadding
                currentRowHeight = 0
                entitiesInCurrentRow = 0
            }
            
            let position = EntityPosition(
                x: currentX,
                y: currentY,
                width: dimensions.width,
                height: dimensions.height
            )
            entityPositions[entity.name] = position
            
            // Update for next entity
            currentX += dimensions.width + entityPadding
            currentRowHeight = max(currentRowHeight, dimensions.height)
            entitiesInCurrentRow += 1
            maxX = max(maxX, currentX)
        }
        
        let finalY = entities.isEmpty ? startY : currentY + currentRowHeight
        return (entityPositions, finalY, maxX)
    }
    
    private func calculateEntityDimensions(entity: Entity) -> (width: Int, height: Int) {
        let headerHeight = 35
        let fieldHeight = 18
        let padding = 12
        let minWidth = 280
        
        // Calculate width based on longest field text
        let maxFieldWidth = entity.fields.map { field in
            let fieldText = formatFieldText(field: field)
            return fieldText.count * 8 + padding * 2 // Approximate character width
        }.max() ?? 0
        
        let titleWidth = entity.name.count * 12 + padding * 2
        let commentWidth = entity.comment != nil ? (entity.comment!.count * 8 + padding * 2) : 0
        let width = max(minWidth, max(maxFieldWidth, max(titleWidth, commentWidth)))
        
        // Calculate height based on field count (comment is now in header area)
        let fieldsHeight = entity.fields.count * fieldHeight
        let height = headerHeight + fieldsHeight + 30 // Extra padding
        
        return (width: width, height: height)
    }
    
    private func calculateLegendHeight(relationships: [Relationship]) -> Int {
        if relationships.isEmpty {
            return 0
        }
        
        let headerHeight = 30
        let rowHeight = 20
        let padding = 20
        
        return headerHeight + (relationships.count * rowHeight) + padding
    }
    
    private func calculateOverviewHeight(overview: ArchitecturalOverview) -> Int {
        let headerHeight = 45
        let lineHeight = 18
        var totalLines = 2 // Title and padding
        let maxCharsPerLine = 70 // Same as used in text wrapping
        
        if overview.purpose != nil { totalLines += 1 }
        if overview.domain != nil { totalLines += 1 }
        if overview.architecturePattern != nil { totalLines += 1 }
        
        // Account for module tag cloud (after pattern)
        let moduleList = getModuleList()
        if !moduleList.isEmpty {
            totalLines += 1 // "Modules:" label
            // More accurate estimation: use almost full width (380px available, starting at 85px offset)
            let avgModuleWidth = 65 // More realistic average including shorter names + spacing
            let availableWidth = 380 - 85 // Full width minus label offset
            let modulesPerLine = max(1, availableWidth / avgModuleWidth)
            let tagCloudLines = (moduleList.count + modulesPerLine - 1) / modulesPerLine
            totalLines += tagCloudLines
            totalLines += 1 // Extra spacing after tag cloud
        }
        
        if !overview.dataDistribution.isEmpty {
            totalLines += 1 // Section header
            for distribution in overview.dataDistribution.prefix(3) {
                let wrappedLines = wrapText(distribution, maxCharsPerLine: maxCharsPerLine)
                totalLines += wrappedLines.count
            }
        }
        
        if !overview.keyFeatures.isEmpty {
            totalLines += 1 // Section header
            for feature in overview.keyFeatures.prefix(3) {
                let wrappedLines = wrapText(feature, maxCharsPerLine: maxCharsPerLine)
                totalLines += wrappedLines.count
            }
        }
        
        if !overview.moduleBreakdown.isEmpty {
            totalLines += 1 // Section header
            for module in overview.moduleBreakdown.prefix(4) {
                let wrappedLines = wrapText(module, maxCharsPerLine: maxCharsPerLine)
                totalLines += wrappedLines.count
            }
        }
        
        return headerHeight + (totalLines * lineHeight) + 35 // Extra padding for features + title spacing
    }
    
    private func generateRelationshipsLegend(relationships: [Relationship], layout: SVGLayout) -> String {
        guard !relationships.isEmpty else { return "" }
        
        let x = layout.legendX
        let y = layout.legendY
        let width = layout.legendWidth
        let height = layout.legendHeight
        let headerHeight = 30
        let rowHeight = 20
        let padding = 10
        
        var legend = """
        <g class="legend">
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(height)" class="legend-box" rx="8"/>
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(headerHeight)" class="legend-header" rx="8"/>
            <text x="\(x + width/2)" y="\(y + headerHeight/2 + 5)" class="legend-title" text-anchor="middle">Relationships</text>
        
        """
        
        // Column headers
        let col1X = x + padding
        let col2X = x + width/3
        let col3X = x + 2*width/3
        let headerY = y + headerHeight + 15
        
        legend += """
            <text x="\(col1X)" y="\(headerY)" class="legend-text" font-weight="bold">From Entity</text>
            <text x="\(col2X)" y="\(headerY)" class="legend-text" font-weight="bold">To Entity</text>
            <text x="\(col3X)" y="\(headerY)" class="legend-text" font-weight="bold">Relationship</text>
        
        """
        
        // Header separator line
        legend += """
            <line x1="\(x + 5)" y1="\(headerY + 5)" x2="\(x + width - 5)" y2="\(headerY + 5)" class="legend-row"/>
        
        """
        
        // Relationship rows
        for (index, relationship) in relationships.enumerated() {
            let rowY = headerY + 15 + (index * rowHeight)
            
            let relationshipText = formatRelationshipForLegend(relationship)
            
            legend += """
                <a href="#\(relationship.fromEntity)" style="cursor: pointer;">
                    <text x="\(col1X)" y="\(rowY)" class="legend-text">\(xmlEscape(relationship.fromEntity))</text>
                </a>
                <a href="#\(relationship.toEntity)" style="cursor: pointer;">
                    <text x="\(col2X)" y="\(rowY)" class="legend-text">\(xmlEscape(relationship.toEntity))</text>
                </a>
                <text x="\(col3X)" y="\(rowY)" class="legend-text">\(xmlEscape(relationshipText))</text>
            
            """
        }
        
        legend += "</g>\n"
        return legend
    }
    
    private func formatRelationshipForLegend(_ relationship: Relationship) -> String {
        var text = relationship.cardinality.rawValue
        if let comment = relationship.comment {
            text += " (\(comment))"
        }
        return text
    }
    
    // MARK: - Architectural Overview Extraction
    
    private func extractArchitecturalOverview() -> ArchitecturalOverview? {
        guard let content = rawContent else { return nil }
        
        let lines = content.components(separatedBy: .newlines)
        var purpose: String?
        var domain: String?
        var pattern: String?
        var moduleBreakdown: [String] = []
        var keyFeatures: [String] = []
        var dataDistribution: [String] = []
        
        var currentSection: String?
        
        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
            
            // Skip non-comment lines
            guard trimmed.hasPrefix("#") else { continue }
            
            if trimmed.contains("SCHEMA ARCHITECTURE OVERVIEW") {
                currentSection = "overview"
                continue
            } else if trimmed.contains("MODULE BREAKDOWN") {
                currentSection = "modules"
                continue
            } else if trimmed.contains("KEY ARCHITECTURAL FEATURES") {
                currentSection = "features"
                continue
            } else if trimmed.contains("DATA DISTRIBUTION") {
                currentSection = "distribution"
                continue
            } else if trimmed.contains("RELATIONSHIP DEFINITIONS") {
                break // End of architectural overview
            }
            
            if currentSection == "overview" {
                let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces) // Remove # prefix
                if content.hasPrefix("Database Purpose:") {
                    purpose = String(content.dropFirst("Database Purpose:".count)).trimmingCharacters(in: .whitespaces)
                } else if content.hasPrefix("Domain:") {
                    domain = String(content.dropFirst("Domain:".count)).trimmingCharacters(in: .whitespaces)
                } else if content.hasPrefix("Architecture Pattern:") {
                    pattern = String(content.dropFirst("Architecture Pattern:".count)).trimmingCharacters(in: .whitespaces)
                }
            } else if currentSection == "modules" {
                let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces) // Remove # prefix
                if !content.isEmpty && !content.hasPrefix("=") && content.contains("entities") {
                    moduleBreakdown.append(content)
                }
            } else if currentSection == "features" {
                let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces) // Remove # prefix
                if content.hasPrefix("-") {
                    let feature = String(content.dropFirst(1)).trimmingCharacters(in: .whitespaces)
                    keyFeatures.append(feature)
                }
            } else if currentSection == "distribution" {
                let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces) // Remove # prefix
                if !content.isEmpty && !content.hasPrefix("=") && content.contains("fields") {
                    dataDistribution.append(content)
                }
            }
        }
        
        guard purpose != nil || domain != nil || !moduleBreakdown.isEmpty else {
            return nil
        }
        
        return ArchitecturalOverview(
            purpose: purpose,
            domain: domain,
            architecturePattern: pattern,
            moduleBreakdown: moduleBreakdown,
            keyFeatures: keyFeatures,
            dataDistribution: dataDistribution
        )
    }
    
    private func generateArchitecturalOverview(_ overview: ArchitecturalOverview, layout: SVGLayout) -> String {
        let x = layout.overviewX
        let y = layout.overviewY
        let width = layout.overviewWidth
        let lineHeight = 18
        var currentY = y + 25
        
        var svg = """
        <g class="architectural-overview">
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(layout.overviewHeight - 20)" 
                  fill="url(#overviewGradient)" stroke="#2c3e50" stroke-width="2" rx="8"/>
            <text x="\(x + width/2)" y="\(y + 20)" class="overview-title" text-anchor="middle">Schema Architecture Overview</text>
        
        """
        
        currentY += 20  // Extra spacing below title for better visual hierarchy
        
        if let purpose = overview.purpose {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-label">Purpose:</text>
            <text x="\(x + 85)" y="\(currentY)" class="overview-text">\(xmlEscape(purpose))</text>
            
            """
            currentY += lineHeight
        }
        
        if let domain = overview.domain {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-label">Domain:</text>
            <text x="\(x + 85)" y="\(currentY)" class="overview-text">\(xmlEscape(domain))</text>
            
            """
            currentY += lineHeight
        }
        
        if let pattern = overview.architecturePattern {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-label">Pattern:</text>
            <text x="\(x + 85)" y="\(currentY)" class="overview-text">\(xmlEscape(pattern))</text>
            
            """
            currentY += lineHeight + 8
        } else {
            currentY += 5
        }
        
        // Module Tag Cloud (after pattern section)
        let moduleList = getModuleList()
        if !moduleList.isEmpty {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-label">Modules:</text>
            
            """
            
            var currentX = x + 85 // Start after the label
            let tagSpacing = 8
            let maxRowWidth = x + width - 20 // Leave minimal padding, use almost full width
            
            for moduleInfo in moduleList {
                let moduleId = "module-\(moduleInfo.name.lowercased())"
                let tagText = moduleInfo.name
                let estimatedWidth = tagText.count * 6 + 12 // More accurate estimate: 6px per char + 12px padding
                
                // Check if we need a new line
                if currentX + estimatedWidth > maxRowWidth {
                    currentY += lineHeight
                    currentX = x + 85
                }
                
                svg += """
                <rect x="\(currentX - 4)" y="\(currentY - 12)" width="\(estimatedWidth)" height="16" 
                      fill="#e8f4f8" stroke="#3498db" stroke-width="1" rx="8" opacity="0.7"/>
                <text x="\(currentX)" y="\(currentY)" class="module-tag" 
                      onclick="document.getElementById('\(moduleId)').scrollIntoView({behavior:'smooth'}); document.getElementById('\(moduleId)').style.outline='3px solid #3498db'; setTimeout(() => document.getElementById('\(moduleId)').style.outline='none', 1000);" 
                      style="cursor: pointer; fill: #2980b9; font-size: 11px;">\(xmlEscape(tagText))</text>
                """
                
                currentX += estimatedWidth + tagSpacing
            }
            currentY += lineHeight + 8
        }
        
        // Data Distribution
        if !overview.dataDistribution.isEmpty {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-section">Data Distribution:</text>
            
            """
            currentY += lineHeight
            
            for distribution in overview.dataDistribution.prefix(3) { // Show max 3 lines
                // Use intelligent text wrapping to preserve all information
                let wrappedLines = wrapText(distribution, maxCharsPerLine: 70)
                
                for (lineIndex, line) in wrappedLines.enumerated() {
                    let prefix = lineIndex == 0 ? "â€¢ " : "  "
                    let textX = x + 25 + (lineIndex == 0 ? 0 : 10)
                    
                    svg += """
                    <text x="\(textX)" y="\(currentY)" class="overview-detail">\(prefix)\(xmlEscape(line))</text>
                    
                    """
                    currentY += lineHeight
                }
            }
            currentY += 5
        }
        
        // Key Architectural Features
        if !overview.keyFeatures.isEmpty {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-section">Key Features:</text>
            
            """
            currentY += lineHeight
            
            for feature in overview.keyFeatures.prefix(3) { // Show max 3 key features
                // Use intelligent text wrapping to preserve all information
                let wrappedLines = wrapText(feature, maxCharsPerLine: 70) // ~70 chars utilizes 400px width better
                
                for (lineIndex, line) in wrappedLines.enumerated() {
                    let prefix = lineIndex == 0 ? "â€¢ " : "  " // Bullet for first line, indent for continuation
                    let textX = x + 25 + (lineIndex == 0 ? 0 : 10) // Extra indent for continuation lines
                    
                    svg += """
                    <text x="\(textX)" y="\(currentY)" class="overview-detail">\(prefix)\(xmlEscape(line))</text>
                    
                    """
                    currentY += lineHeight
                }
            }
            currentY += 5
        }
        
        // Module Breakdown (show first few)
        if !overview.moduleBreakdown.isEmpty {
            svg += """
            <text x="\(x + 15)" y="\(currentY)" class="overview-section">Key Modules:</text>
            
            """
            currentY += lineHeight
            
            for module in overview.moduleBreakdown.prefix(4) { // Show max 4 modules
                // Use intelligent text wrapping to preserve all information
                let wrappedLines = wrapText(module, maxCharsPerLine: 70)
                
                for (lineIndex, line) in wrappedLines.enumerated() {
                    let prefix = lineIndex == 0 ? "â€¢ " : "  "
                    let textX = x + 25 + (lineIndex == 0 ? 0 : 10)
                    
                    svg += """
                    <text x="\(textX)" y="\(currentY)" class="overview-detail">\(prefix)\(xmlEscape(line))</text>
                    
                    """
                    currentY += lineHeight
                }
            }
        }
        
        svg += "</g>\n"
        return svg
    }
    
    private func getModuleList() -> [(name: String, description: String?)] {
        return document.schemaDefinition.moduleSections.map { moduleSection in
            return (name: moduleSection.name, description: moduleSection.description)
        }
    }
    
    private func generateColorLegend(layout: SVGLayout) -> String {
        let x = layout.colorLegendX
        let y = layout.colorLegendY
        let width = layout.colorLegendWidth
        let height = layout.colorLegendHeight
        let headerHeight = 35  // Increased for better title spacing
        let lineHeight = 20   // Better spacing between rows
        let padding = 15
        
        var legend = """
        <g class="color-legend">
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(height)" 
                  fill="url(#overviewGradient)" stroke="#2c3e50" stroke-width="2" rx="8"/>
            <text x="\(x + width/2)" y="\(y + 20)" class="overview-title" text-anchor="middle">Field Color Legend</text>
        
        """
        
        let colorItems = [
            ("Required Fields", "*", "#ffa502", "orange"),
            ("Optional Fields", "-", "#c7c7c7", "gray"),
            ("Indexed Fields", "@", "#5352ed", "blue"),
            ("Sensitive Fields", "#", "#ff4757", "red"),
            ("Foreign Keys", "FK", "#e056fd", "purple"),
            ("Embedded References", "ERF", "#ffeb3b", "yellow")
        ]
        
        let baseY = y + headerHeight + 5  // Reduced gap since headerHeight increased
        
        for (index, (label, symbol, color, _)) in colorItems.enumerated() {
            let row = index / 2  // 2 columns
            let col = index % 2
            let itemX = x + padding + (col * (width - 2 * padding) / 2)
            let itemY = baseY + (row * lineHeight)
            
            legend += """
            <circle cx="\(itemX + 8)" cy="\(itemY - 3)" r="6" fill="\(color)" stroke="#333" stroke-width="1"/>
            <text x="\(itemX + 20)" y="\(itemY - 3)" class="overview-detail" font-size="11px" dominant-baseline="middle">\(xmlEscape(symbol)) - \(xmlEscape(label))</text>
            
            """
        }
        
        legend += "</g>\n"
        return legend
    }
    
    private func generateAttribution(layout: SVGLayout) -> String {
        let x = layout.attributionX
        let y = layout.attributionY
        let width = layout.attributionWidth
        let height = layout.attributionHeight
        
        let attribution = """
        <g class="attribution">
            <!-- Elegant attribution box with gradient and shadow -->
            <rect x="\(x)" y="\(y)" width="\(width)" height="\(height)" 
                  fill="url(#attributionGradient)" 
                  stroke="#5a67d8" stroke-width="1" stroke-opacity="0.6"
                  rx="12" 
                  filter="url(#attributionShadow)"/>
            
            <!-- Main text with elegant styling -->
            <text x="\(x + width/2)" y="\(y + height/2 - 3)" 
                  text-anchor="middle" 
                  font-family="'Segoe UI', Arial, sans-serif" 
                  font-size="14px" 
                  font-weight="600" 
                  fill="#ffffff" 
                  fill-opacity="0.9"
                  style="text-shadow: 0 1px 2px rgba(0,0,0,0.3);">
                \(xmlEscape(Self.attributionTitle))
            </text>
            
            <!-- Subtle version text -->
            <text x="\(x + width/2)" y="\(y + height/2 + 12)" 
                  text-anchor="middle" 
                  font-family="'Segoe UI', Arial, sans-serif" 
                  font-size="10px" 
                  font-weight="400" 
                  fill="#e2e8f0" 
                  fill-opacity="0.8"
                  style="text-shadow: 0 1px 1px rgba(0,0,0,0.2);">
                \(xmlEscape(Self.attributionSubtitle))
            </text>
        </g>
        
        """
        
        return attribution
    }
    
    // MARK: - Text Wrapping
    
    private func wrapText(_ text: String, maxCharsPerLine: Int) -> [String] {
        if text.count <= maxCharsPerLine {
            return [text]
        }
        
        var lines: [String] = []
        var currentLine = ""
        let words = text.split(separator: " ", omittingEmptySubsequences: false)
        
        for word in words {
            let testLine = currentLine.isEmpty ? String(word) : currentLine + " " + String(word)
            
            if testLine.count <= maxCharsPerLine {
                currentLine = testLine
            } else {
                // Current line is full, start a new line
                if !currentLine.isEmpty {
                    lines.append(currentLine)
                }
                currentLine = String(word)
                
                // If a single word is longer than max chars, we need to break it
                if currentLine.count > maxCharsPerLine {
                    let brokenWord = currentLine
                    currentLine = ""
                    // Break long word into chunks
                    var startIndex = brokenWord.startIndex
                    while startIndex < brokenWord.endIndex {
                        let endIndex = brokenWord.index(startIndex, offsetBy: min(maxCharsPerLine, brokenWord.distance(from: startIndex, to: brokenWord.endIndex)))
                        lines.append(String(brokenWord[startIndex..<endIndex]))
                        startIndex = endIndex
                    }
                }
            }
        }
        
        if !currentLine.isEmpty {
            lines.append(currentLine)
        }
        
        return lines
    }
    
    // MARK: - XML Escaping
    
    private func xmlEscape(_ text: String) -> String {
        return text
            .replacingOccurrences(of: "&", with: "&amp;")
            .replacingOccurrences(of: "<", with: "&lt;")
            .replacingOccurrences(of: ">", with: "&gt;")
            .replacingOccurrences(of: "\"", with: "&quot;")
            .replacingOccurrences(of: "'", with: "&apos;")
    }
}

// MARK: - Layout Data Structures

struct SVGLayout {
    var entityPositions: [String: EntityPosition] = [:]
    var moduleHeaders: [(x: Int, y: Int, width: Int, name: String, description: String?)] = []
    var swimlanes: [(x: Int, y: Int, width: Int, height: Int)] = []
    var legendX: Int = 0
    var legendY: Int = 0
    var legendWidth: Int = 0
    var legendHeight: Int = 0
    var overviewHeight: Int = 0
    var overviewX: Int = 0
    var overviewY: Int = 0
    var overviewWidth: Int = 0
    var colorLegendX: Int = 0
    var colorLegendY: Int = 0
    var colorLegendWidth: Int = 0
    var colorLegendHeight: Int = 0
    var attributionX: Int = 0
    var attributionY: Int = 0
    var attributionWidth: Int = 0
    var attributionHeight: Int = 0
    var entitiesStartY: Int = 0
    var totalWidth: Int = 0
    var totalHeight: Int = 0
}

struct EntityPosition {
    let x: Int
    let y: Int
    let width: Int
    let height: Int
}

struct ArchitecturalOverview {
    let purpose: String?
    let domain: String?
    let architecturePattern: String?
    let moduleBreakdown: [String]
    let keyFeatures: [String]
    let dataDistribution: [String]
} 